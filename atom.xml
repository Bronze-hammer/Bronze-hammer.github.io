<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐子辉的个人站点</title>
  
  <subtitle>Change Myself From Now ON.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-02T01:56:08.633Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xuzh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vsftpd配置文件详解</title>
    <link href="http://yoursite.com/2020/04/02/vsftpd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/02/vsftpd配置文件详解/</id>
    <published>2020-04-02T01:31:10.000Z</published>
    <updated>2020-04-02T01:56:08.633Z</updated>
    
    <content type="html"><![CDATA[<p>yum安装的vsftpd配置文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure></p><p>1）以“#”字符开始的行是注释行。每一行为一个选项设置，格式为“option=value”，注意“=”号两边不能留空白符。<br>2）除了这个主配置文件外，还可以给特定用户设定个人配置文件</p><a id="more"></a><h3 id="1-与建立FTP链接相关的选项"><a href="#1-与建立FTP链接相关的选项" class="headerlink" title="1.与建立FTP链接相关的选项"></a>1.与建立FTP链接相关的选项</h3><h4 id="1-1-监听地址与控制端口"><a href="#1-1-监听地址与控制端口" class="headerlink" title="1.1.监听地址与控制端口"></a>1.1.监听地址与控制端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listen_address=[IP]        # 提供ftp服务的主机IP，单IP主机，不需要使用，多IP主机默认监听所有IP地址。在VSFTPD使用单独(standalone)模式下有效。</span><br><span class="line">listen_port=[port]         # 提供ftp服务的控制端口号，默认值为21。此选项在standalone模式下生效。</span><br><span class="line">port_enable=YES            # 是否启用ftp主动模式，默认为YES。如果要在数据连接时取消PORT主动模式时，改为NO</span><br><span class="line">connetc_from_port_20=NO    # 以port主动模式进行数据传输时是否使用20端口，默认为NO不使用。但RHEL自带的vsftpd.conf文件中此参数设为YES。</span><br><span class="line">ftp_data_port=[port]       # 指定ftp数据传输端口值，默认为20。此参数用于主动模式。</span><br><span class="line">port_promiscuous=NO        # 取消PORT安全检查，默认为NO不取消检查。该检查确保外出的数据只能连接到客户端上。不建议打开</span><br><span class="line">pasv_enable=YES            # 允许数据传输时使用PASV被动模式。默认为YES允许被动模式</span><br><span class="line">pasv_min_port=[minport]</span><br><span class="line">pasv_max_port=[maxport]    # 设定在PASV被动模式下，建立数据传输所可以使用port范围的下界和上界，默认为0不限制。</span><br><span class="line">　　　　　　　　　　　　　　   # 把端口范围设在比较高的一段范围内，比如50000-60000，将有助于安全性的提高。</span><br><span class="line">pasv_promiscuous=NO        # 是否关闭PASV模式的安全检查，默认值为NO不关闭。该检查确保数据连接和控制连接是来自同一个IP地址。不建议打开，此选项唯一合理的用法是存在于由安全隧道方案构成的组织中。</span><br><span class="line">pasv_address=[IP]          # 此选项为一个数字IP地址，作为PASV命令的响应。默认值为none，即地址是从呼入的连接套接字(incomingconnectdsocket)中获取。</span><br></pre></td></tr></table></figure><h4 id="1-2-关于ftp服务的ASCII模式"><a href="#1-2-关于ftp服务的ASCII模式" class="headerlink" title="1.2.关于ftp服务的ASCII模式"></a>1.2.关于ftp服务的ASCII模式</h4><p>默认情况下，VSFTPD使用二进制传输数据，禁止使用ASCII传输模式。<br>如果FTP客户端使用ascii命令，指明要使用ASCII模式，VSFTPD表面上接受了ascii命令，但在实际传输文件时，还是使用二进制方式，就会出现乱码文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ascii_upload_enable=NO     #控制是否允许使用ascii模式上传文件，默认为NO不允许。</span><br><span class="line">ascii_download_enable=NO   # 控制是否允许使用ascii模式下载文件，默认为NO不允许。</span><br></pre></td></tr></table></figure></p><h3 id="2-关于性能与负载控制"><a href="#2-关于性能与负载控制" class="headerlink" title="2.关于性能与负载控制"></a>2.关于性能与负载控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">idle_session_timeout=60      # 设置用户会话的空闲中断时间，单位为秒，默认值为300。</span><br><span class="line">data_connection_timeout=120  # 设置空闲的数据连接的中断时间。默认值为300秒。</span><br><span class="line">accept_timeout=60            # 接受建立联机的超时设定，单位为秒。默认值为60。</span><br><span class="line">connect_timeout=60           # 响应PORT方式的数据联机的超时设定，单位为秒。默认值为60。</span><br><span class="line">　　　　　　　　　　　　　　　　　# 以上两个选项针对客户端的，将使客户端空闲1分钟后自动中断连接，并在中断1分钟后自动激活连接。</span><br><span class="line">max_clients=200              # 指明服务器总的客户并发连接数为200，默认值为0，表示不限最大连接数。此参数在使用standalone模式下有效</span><br><span class="line">max_per_ip=3                 # 指明每个IP地址的并发连接数，默认值为0不限制。该设置会影响到象网际快车这类的多进程下载软件。此参数在使用standalone模式下有效</span><br><span class="line">local_max_rate=50000         # 设置本地用户的最大传输速率限制（50kbytes/sec），以Bytes/s为单位。默认0不限制。此选项可以为指定用户单独设置</span><br><span class="line">anon_max_rate=30000          # 设定匿名用户的最大数据传输速度value，以Bytes/s为单位。默认0不限制</span><br><span class="line">pasv_min_port=50000          # 设置被动模式客户端连接时的端口范围，默认为0不限制</span><br><span class="line">pasv_max_port=60000</span><br></pre></td></tr></table></figure><h3 id="3-用户选项"><a href="#3-用户选项" class="headerlink" title="3.用户选项"></a>3.用户选项</h3><p>VSFTPD的用户分为三类：匿名用户、本地用户（localuser）以及虚拟用户</p><h4 id="3-1-匿名用户"><a href="#3-1-匿名用户" class="headerlink" title="3.1.匿名用户"></a>3.1.匿名用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=YES|NO      # 控制是否允许匿名用户登录，默认值为YES允许匿名用户登录。</span><br><span class="line">ftp_username=                # 匿名用户所使用的系统用户名。默认此参数在配置文件中不出现，值为ftp。</span><br><span class="line">no_anon_password=NO          # 控制匿名用户登入时是否需要密码，默认值为NO需要密码。</span><br><span class="line">deny_email_enable=NO         # 拒绝在banned_email_file指定的文件中所列出的email地址进行登录的匿名用户。默认值为NO关闭。这对于阻击某些Dos攻击有效。如果开启需要追加以下配置</span><br><span class="line">banned_email_file=/etc/banned_emails.conf    # 当匿名用户使用banned_email_file文件中所列出的e-mail进行登录时，被拒绝</span><br><span class="line">指定包含被拒绝的e-mail地址的文件，默认文件为/etc/vsftpd.banned_emails。</span><br><span class="line">anon_root=                   # 匿名用户的根目录，默认为/var/ftp/，主配置文件中默认无此项。</span><br><span class="line">anon_world_readable_only=YES # 默认值为YES只允许匿名用户下载可阅读的文件。NO允许匿名用户浏览整个服务器的文件</span><br><span class="line">anon_upload_enable=NO        # 是否允许匿名用户上传文件，默认NO不允许。</span><br></pre></td></tr></table></figure><p>除了anon_upload_enable这个参数外，匿名用户要能上传文件，还需要两个条件：</p><p>1）write_enable参数为YES;<br>2）在文件系统上，FTP匿名用户对某个目录有写权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anon_mkdir_write_enable=NO   # 是否允许匿名用户创建新目录，默认为NO不允许，同时FTP匿名用户必需对新目录的上层目录拥有写权限。</span><br><span class="line">anon_other_write_enable=NO   # 匿名用户是否拥有除了上传和新建目录之外的其他权限，如删除、更名等。默认为NO不拥有</span><br><span class="line">chown_uploads=NO             # 是否修改匿名用户所上传文件的所有权。默认值为NO不修改。如果改为YES匿名用户所上传的文件的所有权将改为另外一个不同的用户所有</span><br><span class="line">chown_username=whoever       # 指定拥有匿名用户上传文件所有权的用户。此参数与chown_uploads联用。不推荐使用root用户。</span><br></pre></td></tr></table></figure><h4 id="3-2-本地用户"><a href="#3-2-本地用户" class="headerlink" title="3.2.本地用户"></a>3.2.本地用户</h4><p>在使用FTP服务的用户中，除了匿名用户外，还有一类在FTP服务器所属主机上拥有账号的用户。VSFTPD中称此类用户为本地用户（localuser），等同于其他FTP服务器中的real用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_enable=YES             # 本地系统用户是否可以登陆，默认值为YES。</span><br><span class="line">local_root=                  # 定义所有本地用户的根目录。默认为空，本地用户登录到自己的宿主目录</span><br><span class="line">user_config_dir=/etc/vsftpd/user.d    # 定义用户个人配置文件所在的目录，配置文件名为用户名，配置格式与vsftpd.conf相同。默认为无不单独设置用户权限，虚拟用户也用这个</span><br></pre></td></tr></table></figure></p><h4 id="3-3-虚拟用户"><a href="#3-3-虚拟用户" class="headerlink" title="3.3.虚拟用户"></a>3.3.虚拟用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guest_enable=NO        　　　 # 若是启动这项功能，所有的非匿名登入者都视为guest，默认值为NO关闭。如果要使用ftp虚拟用户需要启用</span><br><span class="line">guest_username=        　　　 # 定义VSFTPD的guest用户在系统中的用户名。默认值为ftp，在使用ftp虚拟用户时建议自定义，例如ftpvuser</span><br></pre></td></tr></table></figure><h3 id="4-安全措施"><a href="#4-安全措施" class="headerlink" title="4.安全措施"></a>4.安全措施</h3><h4 id="4-1-用户登录控制"><a href="#4-1-用户登录控制" class="headerlink" title="4.1.用户登录控制"></a>4.1.用户登录控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/vsftpd/ftpusers         # 改配置文件中的用户禁止登录FTP服务器。这个机制是在/etc/pam.d/vsftpd中默认设置的。</span><br><span class="line">pam_service_name=vsftpd      # 指定vsftpd进行PAM认证时所使用的PAM配置文件名，默认值是vsftpd，默认PAM配置文件是/etc/pam.d/vsftpd，使用ftp虚拟用户时需要更改</span><br><span class="line">userlist_enable=NO           # 是否通过userlist_file列表控制可登陆的用户，默认为NO不启用，如果启用，列表中的用户默认拒绝登录FTP服务器，在输入用户名后，不提示输入密码</span><br><span class="line">userlist_deny=YES            # 决定禁止还是允许userlist_file指定文件中的用户登录FTP服务器，默认为YES禁止文件中的用户登录，此选项在userlist_enable选项启动后才生效，如果要允许在文件中的用户登录FTP服务器需要改为NO</span><br><span class="line">userlist_file=/etc/vsftpd/user_list    # userlist_enable选项指定的用户列表的文件。默认为/etc/vsftpd/user_list。</span><br><span class="line">tcp_wrappers=YES             # 在vsftpd中使用TCP_Wrappers封装数据，默认值为YES。</span><br></pre></td></tr></table></figure><h3 id="4-2-目录访问控制"><a href="#4-2-目录访问控制" class="headerlink" title="4.2.目录访问控制"></a>4.2.目录访问控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chroot_list_enable=NO        # 是否锁定用户在其宿主目录中，默认值为NO不锁定。具体的用户在chroot_list_file参数所指定的文件中列出。</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list    # 指定要锁定在宿主目录中的用户，默认不设置。一行一用户，通常为/etc/vsftpd/chroot_list</span><br><span class="line">chroot_local_users=NO        # 将本地用户锁定在其宿主目录中，默认值为NO不锁定。</span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">当chroot_local_users被激活时，chroot_list_enable和chroot_local_users参数的作用将发生变化，chroot_list_file所指定文件中的用户将不被锁定在自家目录。</span><br><span class="line">可能带来安全上的冲突，特别是当用户拥有上传、shell访问等权限时。</span><br><span class="line"></span><br><span class="line">passwd_chroot_enable=NO      # 当此选项需与chroot_local_user配合，chroot()容器的位置可以在每个用户的基础上指定。每个用户的容器来源于/etc/passwd中每个用户的自家目录字段。默认值为NO。</span><br></pre></td></tr></table></figure><h4 id="4-3-文件操作控制"><a href="#4-3-文件操作控制" class="headerlink" title="4.3.文件操作控制"></a>4.3.文件操作控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hide_ids=YES|NO              # 是否隐藏文件的所有者和组信息。默认值为NO不隐藏，如果为YES，当用户使用&quot;ls -al&quot;之类的指令时，在目录列表中所有文件的拥有者和组信息都显示为ftp</span><br><span class="line">ls_recurse_enable=YES|NO     # 是否允许使用&quot;ls-R&quot;指令，默认值为NO不允许。如果在一个大型FTP站点的根目录下使用&quot;ls-R&quot;会消耗大量系统资源。</span><br><span class="line">write_enable=YES|NO          # 是否允许使用修改文件系统的FTP的指令，默认为NO不允许，比如STOR、DELE、RNFR、RNTO、MKD、RMD、APPE以及SITE</span><br><span class="line">secure_chroot_dir=           # 安全沙箱目录，指向一个ftp用户无写权限的空目录，默认为/usr/share/empty。当vsftpd不需要访问文件系统时，这个目录将被作为一个安全的容器，用户将被限制在此目录中。</span><br><span class="line">anon_umask=                  # 匿名用户新增文件的umask数值。默认值为077。</span><br><span class="line">file_open_mode=              # 上传文件的权限，默认值为0666。与chmod所使用的数值相同。如果希望上传的文件可以执行，设此值为0777。</span><br><span class="line">local_umask=                 # 本地用户新增文件时的umask数值，默认值为077。如果希望新增的文件他人可以访问的话，修改为022</span><br></pre></td></tr></table></figure><h3 id="5-提示信息"><a href="#5-提示信息" class="headerlink" title="5.提示信息"></a>5.提示信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ftpd_banner=welcome          # 此参数定义了登录欢迎语，预设值为无，可修改</span><br><span class="line">banner_file=/etc/vsftpd/banner_file    # 当用户登录时会显示此文件中的内容，通常为欢迎话语或是说明。默认值为无。</span><br><span class="line">　　　　　　　　　　　　　　　　　# 与ftpd_banner相比，banner_file是文本文件的形式，而ftpd_banner是字串格式。banner_file选项将取代ftpd_banner选项。</span><br><span class="line">dirmessage_enable=YES        # 特定目录的提示信息，默认为YES启用。当用户进入指定目录，如果该目录下存在message_file指定的文件，则显示出现此文档的内容，通常这个文档会放置欢迎话语，或是对该目录的说明。</span><br><span class="line">message_file=                # dirmessage_enable选项启用时生效，指定提示内容的文档。默认为.message，以该扩展名结尾的文件</span><br></pre></td></tr></table></figure><h3 id="6-日志设置"><a href="#6-日志设置" class="headerlink" title="6.日志设置"></a>6.日志设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xferlog_enable=NO            # 是否启用一个日志文件，记录上传和下载，默认为NO不启用，该日志文件由xferlog_file选项指定</span><br><span class="line">xferlog_file=/var/log/vsftpd.log    # 记录ftp日志。默认为/var/log/vsftpd.log</span><br><span class="line">xferlog_std_format=NO        # 日志文件格式是否使用xferlog的标准格式，默认为NO不使用。默认的日志格式更为可读性，使用xferlog格式可以使用已经存在的传输统计生成器。</span><br><span class="line">log_ftp_protocol=NO          # 是否记录所有的FTP请求和响应到日志中，这个选项一般用于调试，默认为NO不记录。使用此选项时xferlog_std_format不能被激活</span><br></pre></td></tr></table></figure><h3 id="7-其他设置"><a href="#7-其他设置" class="headerlink" title="7.其他设置"></a>7.其他设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setproctitle_enable=NO       # 是否在系统进程列表中显示每个会话(session)的状态，默认为NO不显示。包括挂起、下载等</span><br><span class="line">text_userdb_names=No         # 用户使用ls -al命令时，列表信息是否显示拥有者名称而不是UID，默认为NO不显示</span><br><span class="line">use_localtime=NO             # vsftpd显示目录列表时是否使用服务器本地时区的时间。默认为NO显示GMT时间，建议修改为YES。由ftp命令“MDTM”返回的时间值也受此选项影响。</span><br><span class="line">check_shell=YES              # 本地用户登录时vsftpd是否检查/etc/shells文件以寻找一个有效的用户shell。默认为YES。此选项仅对不使用PAM方式的VSFTPD生效。</span><br><span class="line">nopriv_user=nobody           # 指定一个专用的除nobody以外的用户，当VSFTPD不想要什么权限时，使用此用户身份。默认值为nobody，如果使用建议修改，因为在大多数的机器上，nobody用户被用于大量重要的事情</span><br><span class="line">pam_service_name=            # 指明vsftpd使用用PAM验证服务时的PAM配置文件名。默认值为ftp。</span><br></pre></td></tr></table></figure><blockquote><p>文章转载来自<a href="https://www.cnblogs.com/tssc/p/9592600.html" target="_blank" rel="noopener">https://www.cnblogs.com/tssc/p/9592600.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yum安装的vsftpd配置文件如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/vsftpd/vsftpd.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1）以“#”字符开始的行是注释行。每一行为一个选项设置，格式为“option=value”，注意“=”号两边不能留空白符。&lt;br&gt;2）除了这个主配置文件外，还可以给特定用户设定个人配置文件&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="vsftpd" scheme="http://yoursite.com/tags/vsftpd/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂HashMap</title>
    <link href="http://yoursite.com/2020/04/01/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82HashMap/"/>
    <id>http://yoursite.com/2020/04/01/一文读懂HashMap/</id>
    <published>2020-04-01T02:56:07.000Z</published>
    <updated>2020-04-01T03:19:11.231Z</updated>
    
    <content type="html"><![CDATA[<p>编程语言</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编程语言&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤</title>
    <link href="http://yoursite.com/2020/03/26/%E4%B8%8D%E5%B0%B1%E6%98%AFSELECT%20COUNT%E8%AF%AD%E5%8F%A5%E5%90%97%EF%BC%8C%E7%AB%9F%E7%84%B6%E8%83%BD%E8%A2%AB%E9%9D%A2%E8%AF%95%E5%AE%98%E8%99%90%E7%9A%84%E4%BD%93%E6%97%A0%E5%AE%8C%E8%82%A4/"/>
    <id>http://yoursite.com/2020/03/26/不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤/</id>
    <published>2020-03-26T09:38:21.000Z</published>
    <updated>2020-03-26T09:58:45.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章来自 <a href="http://www.hollischuang.com/archives/4057" target="_blank" rel="noopener">Hollis</a></p></blockquote><p>数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。</p><p>在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。</p><a id="more"></a><p>关于数据库中行数统计，无论是MySQL还是Oracle，都有一个函数可以使用，那就是COUNT。<br>但是，就是这个常用的COUNT函数，却暗藏着很多玄机，尤其是在面试的时候，一不小心就会被虐。不信的话请尝试回答下以下问题：</p><blockquote><p>1、COUNT有几种用法？<br>2、COUNT(字段名)和COUNT(<em>)的查询结果有什么不同？<br>3、COUNT(1)和COUNT(</em>)之间有什么不同？<br>4、COUNT(1)和COUNT(<em>)之间的效率哪个更高？<br>5、为什么《阿里巴巴Java开发手册》建议使用COUNT(</em>)<br>6、MySQL的MyISAM引擎对COUNT(<em>)做了哪些优化？<br>7、MySQL的InnoDB引擎对COUNT(</em>)做了哪些优化？<br>8、上面提到的MySQL对COUNT(<em>)做的优化，有一个关键的前提是什么？<br>9、SELECT COUNT(</em>) 的时候，加不加where条件有差别吗？<br>10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？</p></blockquote><p>以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解COUNT函数了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。</p><h3 id="认识COUNT"><a href="#认识COUNT" class="headerlink" title="认识COUNT"></a>认识COUNT</h3><p>关于COUNT函数，在MySQL官网中有详细介绍：</p><img src="/2020/03/26/不就是SELECT%20COUNT语句吗，竟然能被面试官虐的体无完肤/15709530990912-1.jpg"><p>简单翻译一下：</p><p>1、COUNT(expr) ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个BIGINT值。</p><p>2、如果查询结果没有命中任何记录，则返回0</p><p>3、但是，值得注意的是，COUNT(*) 的统计结果中，会包含值为NULL的行数。</p><p>即以下表记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="comment">#bla(id int,id2 int)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">#bla values(null,null)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">#bla values(1,null)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">#bla values(null,1)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">#bla values(1,null)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">#bla values(null,1)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">#bla values(1,null)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">#bla values(null,null)</span></span><br></pre></td></tr></table></figure><p>使用语句count(*),count(id),count(id2)查询结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">count</span>(<span class="keyword">id</span>),<span class="keyword">count</span>(id2)</span><br><span class="line"><span class="keyword">from</span> <span class="comment">#bla</span></span><br></pre></td></tr></table></figure><p>results 7 3 2</p><p>除了COUNT(id)和COUNT(*)以外，还可以使用COUNT(常量)（如COUNT(1)）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 COUNT(列名)或 COUNT(常量)来替代 COUNT(*)呢？</p><img src="/2020/03/26/不就是SELECT%20COUNT语句吗，竟然能被面试官虐的体无完肤/15672369567349-1.jpg"><h3 id="COUNT-列名-、COUNT-常量-和COUNT-之间的区别"><a href="#COUNT-列名-、COUNT-常量-和COUNT-之间的区别" class="headerlink" title="COUNT(列名)、COUNT(常量)和COUNT(*)之间的区别"></a>COUNT(列名)、COUNT(常量)和COUNT(*)之间的区别</h3><p>前面我们提到过COUNT(expr)用于做行数统计，统计的是expr不为NULL的行数，那么COUNT(列名)、 COUNT(常量) 和 COUNT(<em>)这三种语法中，expr分别是列名、 常量 和 </em>。</p><p>那么列名、 常量 和 *这三个条件中，常量 是一个固定值，肯定不为NULL。*可以理解为查询整行，所以肯定也不为NULL，那么就只有列名的查询结果有可能是NULL了。</p><p>所以， COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</p><p>除了查询得到结果集有区别之外，COUNT(*)相比COUNT(常量) 和 COUNT(列名)来讲，COUNT(*)是SQL92定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。</p><blockquote><p>SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。</p></blockquote><h3 id="COUNT-的优化"><a href="#COUNT-的优化" class="headerlink" title="COUNT(*)的优化"></a>COUNT(*)的优化</h3><p>前面提到了COUNT(*)是SQL92定义的标准统计行数的语法，所以MySQL数据库对他进行过很多优化。那么，具体都做过哪些事情呢？</p><p>这里的介绍要区分不同的执行引擎。MySQL中比较常用的执行引擎就是InnoDB和MyISAM。</p><p>MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的COUNT(*)有关，那就是MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。</p><p>因为MyISAM的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用COUNT(*)进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。</p><p>MyISAM之所以可以把表中的总行数记录下来供COUNT(*)查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。</p><p>但是，对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。</p><p>但是，InnoDB还是针对COUNT(*)语句做了些优化的。</p><p>在InnoDB中，使用COUNT(*)查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。</p><p>从MySQL 8.0.13开始，针对InnoDB的 <code>SELECT COUNT(*) FROM tbl_name</code> 语句，确实在扫表的过程中做了一些优化。前提是查询语句中不包含WHERE或GROUP BY等条件。</p><p>我们知道，COUNT(*)的目的只是为了统计总行数，所以，他根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。</p><p>我们知道，InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。</p><p>所以，相比之下，非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。</p><p>至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。</p><h3 id="COUNT-和COUNT-1"><a href="#COUNT-和COUNT-1" class="headerlink" title="COUNT(*)和COUNT(1)"></a>COUNT(*)和COUNT(1)</h3><p>介绍完了COUNT(<em>)，接下来看看COUNT(1)，对于，这二者到底有没有区别，网上的说法众说纷纭。<br>有的说COUNT(</em>)执行时会转换成COUNT(1)，所以COUNT(1)少了转换步骤，所以更快。<br>还有的说，因为MySQL针对COUNT(*)做了特殊优化，所以COUNT(*)更快。</p><p>那么，到底哪种说法是对的呢？看下MySQL官方文档是怎么说的：</p><blockquote><p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p></blockquote><p>画重点：<code>same way , no performance difference。</code>所以，对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！</p><p>那既然COUNT(*)和COUNT(1)一样，建议用哪个呢？</p><p>建议使用COUNT(*)！因为这个是SQL92定义的标准统计行数的语法，而且本文只是基于MySQL做了分析，关于Oracle中的这个问题，也是众说纷纭的呢。</p><h3 id="COUNT-字段"><a href="#COUNT-字段" class="headerlink" title="COUNT(字段)"></a>COUNT(字段)</h3><p>最后，就是我们一直还没提到的COUNT(字段)，他的查询就比较简单粗暴了，就是进行全表扫描，然后判断指定字段的值是不是为NULL，不为NULL则累加。<br>相比COUNT(*)，COUNT(字段)多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比COUNT(*)慢。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了COUNT函数的用法，主要用于统计表行数。主要用法有COUNT(<em>)、COUNT(字段)和COUNT(1)。<br>因为COUNT(\</em>)是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT(*)查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。</p><p>在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样，但是COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些。</p><p>因为COUNT(*)是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用COUNT(*)查询表的行数！</p><p>参考资料： <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count</a> 《极客时间——MySQL实战45讲》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章来自 &lt;a href=&quot;http://www.hollischuang.com/archives/4057&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hollis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。&lt;/p&gt;
&lt;p&gt;在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
      <category term="COUNT" scheme="http://yoursite.com/tags/COUNT/"/>
    
  </entry>
  
  <entry>
    <title>Oracle索引</title>
    <link href="http://yoursite.com/2020/03/23/Oracle%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/03/23/Oracle索引/</id>
    <published>2020-03-23T02:41:40.000Z</published>
    <updated>2020-03-26T09:39:37.090Z</updated>
    
    <content type="html"><![CDATA[<p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。 </p><p>在没有创建索引之前，如果要按照用户名字段username全表查询一条用户数据，就要必须在全表都搜索一遍；在username上创建索引，Oracle会对全表进行一次搜索，将每条记录的username按照顺序排序，然后构建索引条目（name和rowid），存储到索引段中。在接下来查找username等于某个值时即可直接查找到相应的地方。</p><a id="more"></a><blockquote><p>文章来自 <a href="https://www.oraclejsq.com/article/010100478.html" target="_blank" rel="noopener">FREE教程</a></p></blockquote><p>既然我们都知道建立索引有利于查询速率的提升，那是不是所有字段都可以加上索引。这是万万不行的，建立索引不仅仅要浪费空间来存储索引表，当数据量较少时，直接查询数据比经过查询索引表再定位到表数据的速度更快。索引可以提高查询的效率，但是在数据增删改时需要更新索引，因此索引对增删改时会有负面影响。所以要根据实际情况， 考虑好再建立索引。</p><h3 id="何时建立索引"><a href="#何时建立索引" class="headerlink" title="何时建立索引"></a>何时建立索引</h3><p>那何时建立索引，下面大概介绍几点，其余的得在实际应用和开发过程中，酌情考虑：</p><p>1、Oracle 数据库会为表的主键和包含唯一约束的列自动创建索引，所以在建立唯一约束时，可以考虑该列是否必要建立。是否经常要作为查询条件。</p><p>2、如果某个表的数据量较大（十几二十万以上），某列经常作为where的查询条件，并且检索的出来的行数经常是小于总表的5%，那该列可以考虑建立索引。</p><p>3、对于两表连接的字段，应该考虑建立索引。如果经常在某表的一个字段进行Order By 则也经过进行索引。</p><p>4、不应该在小表上建立索引。上面也说过，小表之间查询的数据会比建立索引的查询速度更快，但是在某些字段，如性别：只有男、女和未知三种数据时，可以考虑位图索引，可以增加查询效率。</p><p>5、经常进行DML操作，即经常进行增删改的操作的表，创建表索引时就要权衡一下，因为建索引会导致进行DML操作时速度变慢。所以可以根据实际情况，选择某些字段建立索引，而不能盲目乱建。</p><h3 id="索引的类别"><a href="#索引的类别" class="headerlink" title="索引的类别"></a>索引的类别</h3><p>适当的使用索引可以提高数据检索速度，那Oracle有哪些类型的索引呢？</p><p>1、b-tree索引：Oracle数据中最常见的索引，就是b-tree索引，create index创建的normal就是b-tree索引，没有特殊的必须应用在哪些数据上。</p><p>2、bitmap位图索引：位图索引经常应用于列数据只有几个枚举值的情况，比如上面说到过的性别字段，或者我们经常开发中应用的代码字段。这个时候使用bitmap位图索引，查询效率将会最快。</p><p>3、函数索引：比如经常对某个字段做查询的时候经常是带函数操作的，那么此时建一个函数索引就有价值了。例如：trim（列名）或者substr(列名)等等字符串操作函数，这个时候可以建立函数索引来提升这种查询效率。</p><p>4、hash索引：hash索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。创建hash索引必须使用hash集群，相当于定义了一个hash集群键，通过这个集群键来告诉oracle来存储表。因此，需要在创建hash集群的时候指定这个值。存储数据时，所有相关集群键的行都存储在一个数据块当中，所以只要定位到hash键，就能快速定位查询到数据的物理位置。</p><p>5、reverse反向索引：这个索引不经常使用到，但是在特定的情况下，是使用该索引可以达到意想不到的效果。如：某一列的值为{10000,10001,10021,10121,11000,….}，假如通过b-tree索引，大部分都密集发布在某一个叶子节点上，但是通过反向处理后的值将变成{00001,10001,12001,12101,00011,…}，很明显的发现他们的值变得比较随机，可以比较平均的分部在各个叶子节点上，而不是之前全部集中在某一个叶子节点上，这样子就可大大提高检索的效率。</p><p>6、分区索引和分区表的全局索引：这两个索引是应用在分区表上面的，前者的分区索引是对分区表内的单个分区进行数据索引，后者是对分区表的全表进行全局索引。分区表的介绍，可以后期再做单独详解，这里就不累述了。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="语法结构："><a href="#语法结构：" class="headerlink" title="语法结构："></a>语法结构：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>[<span class="keyword">unique</span>]|[<span class="keyword">bitmap</span>] <span class="keyword">index</span> index_name <span class="comment">--UNIQUE表示唯一索引、BITMAP位图索引</span></span><br><span class="line"><span class="keyword">on</span> table_name(column1,column2...|[express])<span class="comment">--express表示函数索引</span></span><br><span class="line">[<span class="keyword">tablespace</span> tab_name] <span class="comment">--tablespace表示索引存储的表空间</span></span><br><span class="line">[pctfree n1]    <span class="comment">--索引块的空闲空间n1</span></span><br><span class="line">[<span class="keyword">storage</span>         <span class="comment">--存储块的空间</span></span><br><span class="line"> (</span><br><span class="line">    <span class="keyword">initial</span> <span class="number">64</span>K  <span class="comment">--初始64k</span></span><br><span class="line">    <span class="keyword">next</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">minextents</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">maxextents</span> <span class="keyword">unlimited</span></span><br><span class="line"> </span><br><span class="line">)];</span><br></pre></td></tr></table></figure><blockquote><p>Oracle要求创建索引的列不能超过32列</p></blockquote><h4 id="语法解析："><a href="#语法解析：" class="headerlink" title="语法解析："></a>语法解析：</h4><p>1、UNIQUE:指定索引列上的值必须是唯一的。称为唯一索引，BITMAP表示位图索引。</p><p>2、index_name：指定索引名。</p><p>3、tabl_name：指定要为哪个表创建索引。</p><p>4、column_name：指定要对哪个列创建索引。我们也可以对多列创建索引，这种索引称为组合索引。也可以是函数表达式，这种就是函数索引。</p><h3 id="修改索引："><a href="#修改索引：" class="headerlink" title="修改索引："></a>修改索引：</h3><h4 id="1、重命名索引："><a href="#1、重命名索引：" class="headerlink" title="1、重命名索引："></a>1、重命名索引：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> index_old <span class="keyword">rename</span> <span class="keyword">to</span> index_new;<span class="comment">--重新命名索引</span></span><br></pre></td></tr></table></figure><h4 id="2、合并索引、重新构造索引：我们索引建好后，经过很长一段时间的使用，索引表中存储的空间会产生一些碎片，导致索引的查询效率会有所下降，这个时候可以合并索引，原理是按照索引规则重新分类存储一下，或者也可以选择删除索引重新构造索引。"><a href="#2、合并索引、重新构造索引：我们索引建好后，经过很长一段时间的使用，索引表中存储的空间会产生一些碎片，导致索引的查询效率会有所下降，这个时候可以合并索引，原理是按照索引规则重新分类存储一下，或者也可以选择删除索引重新构造索引。" class="headerlink" title="2、合并索引、重新构造索引：我们索引建好后，经过很长一段时间的使用，索引表中存储的空间会产生一些碎片，导致索引的查询效率会有所下降，这个时候可以合并索引，原理是按照索引规则重新分类存储一下，或者也可以选择删除索引重新构造索引。"></a>2、合并索引、重新构造索引：我们索引建好后，经过很长一段时间的使用，索引表中存储的空间会产生一些碎片，导致索引的查询效率会有所下降，这个时候可以合并索引，原理是按照索引规则重新分类存储一下，或者也可以选择删除索引重新构造索引。</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> index_name <span class="keyword">coalesce</span>;<span class="comment">--合并索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> index_name <span class="keyword">rebuild</span>;<span class="comment">--重新构造</span></span><br></pre></td></tr></table></figure><h3 id="删除索引："><a href="#删除索引：" class="headerlink" title="删除索引："></a>删除索引：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name;</span><br></pre></td></tr></table></figure><h3 id="查看索引："><a href="#查看索引：" class="headerlink" title="查看索引："></a>查看索引：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.INDEX_NAME,<span class="comment">--索引名字</span></span><br><span class="line">       t.index_type,<span class="comment">--索引类型</span></span><br><span class="line">       t.TABLESPACE_NAME,<span class="comment">--表空间</span></span><br><span class="line">       t.status,<span class="comment">--状态</span></span><br><span class="line">       t.UNIQUENESS<span class="comment">--是否唯一索引</span></span><br><span class="line">  <span class="keyword">from</span> all_indexes T </span><br><span class="line">  <span class="keyword">where</span>  t.INDEX_NAME=<span class="string">'index_name'</span>;</span><br></pre></td></tr></table></figure><h3 id="案例分析："><a href="#案例分析：" class="headerlink" title="案例分析："></a>案例分析：</h3><h4 id="案例1、学生信息表（stuinfo）创建的时候就对学号（stuid）设置了主键（PK-STUINFO），当我们学生信息表数据量大的情况下，我们明显发现班号（classno）需要一个索引，不仅仅是用来关联班级信息表（class）、而且经常作为查询条件，因此创建脚本如下："><a href="#案例1、学生信息表（stuinfo）创建的时候就对学号（stuid）设置了主键（PK-STUINFO），当我们学生信息表数据量大的情况下，我们明显发现班号（classno）需要一个索引，不仅仅是用来关联班级信息表（class）、而且经常作为查询条件，因此创建脚本如下：" class="headerlink" title="案例1、学生信息表（stuinfo）创建的时候就对学号（stuid）设置了主键（PK_STUINFO），当我们学生信息表数据量大的情况下，我们明显发现班号（classno）需要一个索引，不仅仅是用来关联班级信息表（class）、而且经常作为查询条件，因此创建脚本如下："></a>案例1、学生信息表（stuinfo）创建的时候就对学号（stuid）设置了主键（PK_STUINFO），当我们学生信息表数据量大的情况下，我们明显发现班号（classno）需要一个索引，不仅仅是用来关联班级信息表（class）、而且经常作为查询条件，因此创建脚本如下：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> STUDENT.IDX_STUINFO_CLASSNO <span class="keyword">on</span> STUDENT.STUINFO (CLASSNO)</span><br><span class="line">  <span class="keyword">tablespace</span> <span class="keyword">USERS</span></span><br><span class="line">  pctfree <span class="number">10</span></span><br><span class="line">  <span class="keyword">initrans</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">maxtrans</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">storage</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">initial</span> <span class="number">64</span>K</span><br><span class="line">    <span class="keyword">next</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">minextents</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">maxextents</span> <span class="keyword">unlimited</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h4 id="案例2、对于学生信息我们经常用性别作为统计条件进行对学生信息进行统计，因此我们可以在性别（sex）建立一个位图索引进行查询优化。代码如下："><a href="#案例2、对于学生信息我们经常用性别作为统计条件进行对学生信息进行统计，因此我们可以在性别（sex）建立一个位图索引进行查询优化。代码如下：" class="headerlink" title="案例2、对于学生信息我们经常用性别作为统计条件进行对学生信息进行统计，因此我们可以在性别（sex）建立一个位图索引进行查询优化。代码如下："></a>案例2、对于学生信息我们经常用性别作为统计条件进行对学生信息进行统计，因此我们可以在性别（sex）建立一个位图索引进行查询优化。代码如下：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">bitmap</span> <span class="keyword">index</span> STUDENT.IDX_STUINFO_SEX <span class="keyword">on</span> STUDENT.STUINFO (SEX)</span><br><span class="line">  <span class="keyword">tablespace</span> <span class="keyword">USERS</span></span><br><span class="line">  pctfree <span class="number">10</span></span><br><span class="line">  <span class="keyword">initrans</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">maxtrans</span> <span class="number">255</span></span><br><span class="line">  <span class="keyword">storage</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">initial</span> <span class="number">64</span>K</span><br><span class="line">    <span class="keyword">next</span> <span class="number">1</span>M</span><br><span class="line">    <span class="keyword">minextents</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">maxextents</span> <span class="keyword">unlimited</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h4 id="查询一下三种索引的状态："><a href="#查询一下三种索引的状态：" class="headerlink" title="查询一下三种索引的状态："></a>查询一下三种索引的状态：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.INDEX_NAME,</span><br><span class="line">       t.index_type,</span><br><span class="line">       t.TABLESPACE_NAME,</span><br><span class="line">       t.status,</span><br><span class="line">       t.UNIQUENESS</span><br><span class="line">  <span class="keyword">from</span> all_indexes T</span><br><span class="line">  <span class="keyword">where</span> t.TABLE_NAME=<span class="string">'STUINFO'</span></span><br><span class="line">  <span class="keyword">AND</span> T.OWNER=<span class="string">'STUDENT'</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><img src="/2020/03/23/Oracle索引/queryIndex.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。 &lt;/p&gt;
&lt;p&gt;在没有创建索引之前，如果要按照用户名字段username全表查询一条用户数据，就要必须在全表都搜索一遍；在username上创建索引，Oracle会对全表进行一次搜索，将每条记录的username按照顺序排序，然后构建索引条目（name和rowid），存储到索引段中。在接下来查找username等于某个值时即可直接查找到相应的地方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>理解线程安全</title>
    <link href="http://yoursite.com/2019/05/28/%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2019/05/28/理解线程安全/</id>
    <published>2019-05-28T09:04:43.000Z</published>
    <updated>2020-01-14T10:12:33.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="https://mp.weixin.qq.com/s/DJv7h8axGerrmCQFGSpj8Q" target="_blank" rel="noopener"> 编程新说李新杰</a></p></blockquote><h3 id="不是线程的安全"><a href="#不是线程的安全" class="headerlink" title="不是线程的安全"></a>不是线程的安全</h3><p>面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。</p><p>论语中有句话叫“学而优则仕”，相信很多人都觉得是“学习好了可以做官”。然而，这样理解却是错的。切记望文生义。</p><p>同理，“线程安全”也不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。</p><p>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。</p><p>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。</p><p>假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。</p><p>比如把你住的小区看作一个进程，小区里的道路/绿化等就属于公共区域。你拿1万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。</p><p>因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。</p><p>所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。</p><p>即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程“破坏”。</p><p>那我们该怎么办呢？<strong><em>解决问题的过程其实就是一个取舍的过程，不同的解决方案有不同的侧重点。</em></strong></p><a id="more"></a><h3 id="私有的东西就不该让别人知道"><a href="#私有的东西就不该让别人知道" class="headerlink" title="私有的东西就不该让别人知道"></a>私有的东西就不该让别人知道</h3><p>现实中很多人都会把1万块钱藏着掖着，不让无关的人知道，所以根本不可能扔到大马路上。因为这钱是你的私有物品。</p><p>在程序中也是这样的，所以操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问。这也是由操作系统保障的。</p><p>如果一些数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。较为常见的就是局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">avgScore</span><span class="params">(<span class="keyword">double</span>[] scores)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> score : scores) &#123;</span><br><span class="line">        sum += score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = scores.length;</span><br><span class="line">    <span class="keyword">double</span> avg = sum / count;</span><br><span class="line">    <span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的变量sum，count，avg都是局部变量，它们都会被分配在线程栈内存中。</p><p>假如现在A线程来执行这个方法，这些变量会在A的栈内存分配。与此同时，B线程也来执行这个方法，这些变量也会在B的栈内存中分配。</p><p>也就是说这些局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。</p><p>就像每个人的家只属于自己，其他人不能进来。所以你把1万块钱放到家里，其他人是不会知道的。且一般还会放到某个房间里，而不是仍在客厅的桌子上。</p><p>所以把自己的东西放到自己的私人地盘，是安全的，因为其他人无法知道。而且越隐私的地方越好。</p><h3 id="大家不要抢，人人有份"><a href="#大家不要抢，人人有份" class="headerlink" title="大家不要抢，人人有份"></a>大家不要抢，人人有份</h3><p>相信聪明的你已经发现，上面的解决方案是基于“位置”的。因为你放东西的“位置”只有你自己知道（或能到达），所以东西是安全的，因此这份安全是由“位置”来保障的。</p><p>在程序里就对应于方法的局部变量。局部变量之所以是安全的，就是因为定义它的“位置”是在方法里。这样一来安全是达到了，但是它的使用范围也就被限制在这个方法里了，其它方法想用也不用了啦。</p><p>现实中往往会有一个变量需要多个方法都能够使用的情况，此时定义这个变量的“位置”就不能在方法里面了，而应该在方法外面。即从（方法的）局部变量变为（类的）成员变量，其实就是“位置”发生了变化。</p><p>那么按照主流编程语言的规定，类的成员变量不能再分配在线程的栈内存中，而应该分配在公共的堆内存中。其实也就是变量在内存中的“位置”发生了变化，由一个私有区域来到了公共区域。因此潜在的安全风险也随之而来。</p><p>那怎么保证在公共区域的东西安全呢？答案就是，大家不要抢，人人有份。设想你在街头免费发放矿泉水，来了1万人，你却只有1千瓶水，结果可想而知，一拥而上，场面失守。但如果你有10万瓶水，大家一看，水多着呢，不用着急，一个个排着队来，因为肯定会领到。</p><p>东西多了，自然就不值钱了，从另一个角度来说，也就安全了。大街上的共享单车，现在都很安全，因为太多了，到处都是，都长得一样，所以连搞破坏的人都放弃了。因此要让一个东西安全，就疯狂的copy它吧。</p><p>回到程序里，要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。相信你已经猜到了，我要表达的就是ThreadLocal类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAssistant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;String&gt; realName = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    ThreadLocal&lt;Double&gt; totalScore = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">determineDegree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> score = totalScore.get();</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"D"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"E"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">determineOptionalcourseScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> score = totalScore.get();</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个学生助手类有两个成员变量，realName和totalScore，都是ThreadLocal类型的。每个线程在运行时都会拷贝一份存储到自己的本地。</p><p>A线程运行的是“张三”和“90”，那么这两个数据“张三”和“90”是存储到A线程对象（Thread类的实例对象）的成员变量里去了。假设此时B线程也在运行，是“李四”和“85”，那么“李四”和“85”这两个数据是存储到了B线程对象（Thread类的实例对象）的成员变量里去了。</p><p>线程类（Thread）有一个成员变量，类似于Map类型的，专门用于存储ThreadLocal类型的数据。从逻辑从属关系来讲，这些ThreadLocal数据是属于Thread类的成员变量级别的。从所在“位置”的角度来讲，这些ThreadLocal数据是分配在公共区域的堆内存中的。</p><p>说的直白一些，就是把堆内存中的一个数据复制N份，每个线程认领1份，同时规定好，每个线程只能玩自己的那份，不准影响别人的。</p><p>需要说明的是这N份数据都还是存储在公共区域堆内存里的，经常听到的“线程本地”，是从逻辑从属关系上来讲的，这些数据和线程一一对应，仿佛成了线程自己“领地”的东西了。其实从数据所在“位置”的角度来讲，它们都位于公共的堆内存中，只不过被线程认领了而已。这一点我要特地强调一下。</p><p>其实就像大街上的共享单车。原来只有1辆，大家抢着骑，老出问题。现在从这1辆复制出N辆，每人1辆，各骑各的，问题得解。共享单车就是数据，你就是线程。骑行期间，这辆单车从逻辑上来讲是属于你的，从所在位置上来讲还是在大街上这个公共区域的，因为你发现每个小区大门口都贴着“共享单车，禁止入门”。哈哈哈哈。</p><p>共享单车是不是和ThreadLocal很像呀。<strong><em>再重申一遍，ThreadLocal就是，把一个数据复制N份，每个线程认领一份，各玩各的，互不影响。</em></strong></p><h3 id="只能看，不能摸"><a href="#只能看，不能摸" class="headerlink" title="只能看，不能摸"></a>只能看，不能摸</h3><p>放在公共区域的东西，只是存在潜在的安全风险，并不是说一定就不安全。有些东西虽然也在公共区域放着，但也是十分安全的。比如你在大街上放一个上百吨的石头雕像，就非常安全，因为大家都弄不动它。</p><p>再比如你去旅游时，经常发现一些珍贵的东西，会被用铁栅栏围起来，上面挂一个牌子，写着“只能看，不能摸”。当然可以国际化一点，“only look，don’t touch”。这也是很安全的，因为光看几眼是不可能看坏的。</p><p>回到程序里，这种情况就属于，只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAssistant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> passScore = <span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如把及格分数设定为60分，在前面加上一个final，这样所有线程都动不了它了。这就很安全了。</p><p>小节一下：以上三种解决方案，其实都是在“耍花招”。</p><p><strong>第一种，找个只有自己知道的地方藏起来，当然安全了。</strong></p><p><strong>第二种，每人复制1份，各玩各的，互不影响，当然也安全了。</strong></p><p><strong>第三种，更狠了，直接规定，只能读取，禁止修改，当然也安全了。</strong></p><p>是不是都在“避重就轻”呀。如果这三种方法都解决不了，该怎么办呢？Don’t worry，just continue reading。</p><h3 id="没有规则，那就先入为主"><a href="#没有规则，那就先入为主" class="headerlink" title="没有规则，那就先入为主"></a>没有规则，那就先入为主</h3><p>前面给出的三种方案，有点“理想化”了。现实中的情况其实是非常混乱嘈杂的，没有规则的。</p><p>比如在中午高峰期你去饭店吃饭，进门后发现只剩一个空桌子了，你心想先去点餐吧，回来就坐这里吧。当你点完餐回来后，发现已经被别人捷足先登了。</p><p>因为桌子是属于公共区域的物品，任何人都可以坐，那就只能谁先抢到谁坐。虽然你在人群中曾多看了它一眼，但它并不会记住你容颜。</p><p>解决方法就不用我说了吧，让一个人在那儿看着座位，其它人去点餐。这样当别人再来的时候，你就可以理直气壮的说，“不好意思，这个座位，我，已经占了”。</p><p>我再次相信聪明的你已经猜到了我要说的东西了，没错，就是（互斥）锁。</p><p>回到程序里，如果公共区域（堆内存）的数据，要被多个线程操作时，为了确保数据的安全（或一致）性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说吧。</p><p>假设一个线程来到数据跟前一看，发现锁是空闲的，没有人持有。于是它就拿到了这把锁，然后开始操作数据，干了一会活，累了，就去休息了。</p><p>这时，又来了一个线程，发现锁被别人持有着，按照规定，它不能操作数据，因为它无法得到这把锁。当然，它可以选择等待，或放弃，转而去干别的。</p><p>第一个线程之所以敢大胆的去睡觉，就是因为它手里拿着锁呢，其它线程是不可能操作数据的。当它回来后继续把数据操作完，就可以把锁给释放了。锁再次回到空闲状态，其它线程就可以来抢这把锁了。还是谁先抢到锁谁操作数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAssistant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> totalScore = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addScore</span><span class="params">(<span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        lock.obtain();</span><br><span class="line">        totalScore += score;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subScore</span><span class="params">(<span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        lock.obtain();</span><br><span class="line">        totalScore -= score;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定一个班级的初始分数是60分，这个班级抽出10名学生来同时参加10个不同的答题节目，每个学生答对一次为班级加上5分，答错一次减去5分。因为10个学生一起进行，所以这一定是一个并发情形。</p><p>因此加分和减分这两个方法被并发的调用，它们共同操作总分数。为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。</p><h3 id="相信世界充满爱，即使被伤害"><a href="#相信世界充满爱，即使被伤害" class="headerlink" title="相信世界充满爱，即使被伤害"></a>相信世界充满爱，即使被伤害</h3><p>再回到一开始的例子，假如你往地上仍1万块钱，是不是一定会丢呢？这要看情况了，如果是在人来人往的都市，可以说肯定会丢的。如果你跑到无人区扔地上，可以说肯定不会丢。</p><p>可以看到，都是把东西无保护的放到公共区域里，结果却相差很大。这说明安全问题还和公共区域的环境状况有关系。</p><p>比如我把数据放到公共区域的堆内存中，但是始终都只会有1个线程，也就是单线程模型，那这数据肯定是安全的。</p><p>再者说，2个线程操作同一个数据和200个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，线程越少数据不安全的概率越小。取个极限情况，那就是只有1个线程，那不安全概率就是0，也就是安全的。</p><p>可能你又猜到了我想表达的内容了，没错，就是CAS。可能大家觉得既然锁可以解决问题，那就用锁得了，为啥又冒出了个CAS呢？</p><p>那是因为锁的获取和释放是要花费一定代价的，如果在线程数目特别少的时候，可能根本就不会有别的线程来操作数据，此时你还要获取锁和释放锁，可以说是一种浪费。</p><p>针对这种“地广人稀”的情况，专门提出了一种方法，叫CAS（Compare And Swap）。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用CAS。</p><p>假如一个线程操作数据，干了一半活，累了，想要去休息。（貌似今天的线程体质都不太好）。于是它记录下当前数据的状态（就是数据的值），回家睡觉了。</p><p>醒来后打算继续接着干活，但是又担心数据可能被修改了，于是就把睡觉前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明自己在睡觉期间，数据没有被人动过（当然也有可能是先被改成了其它，然后又改回来了，这就是ABA问题了），那就接着继续干。如果不一样，说明数据已经被修改了，那之前做的那些操作其实都白瞎了，就干脆放弃，从头再重新开始处理一遍。</p><p>所以CAS这种方式适用于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。如果并发量很高的话，你的数据一定会被修改，每次都要放弃，然后从头再来，这样反而花费的代价更大了，还不如直接加锁呢。</p><p>这里再解释下ABA问题，假如你睡觉前数据是5，醒来后数据还是5，并不能肯定数据没有被修改过。可能数据先被修改成8然后又改回到5，只是你不知道罢了。对于这个问题，其实也很好解决，再加一个版本号字段就行了，并规定只要修改数据，必须使版本号加1。</p><p>这样你睡觉前数据是5版本号是0，醒来后数据是5版本号是0，表明数据没有被修改。如果数据是5版本号是2，表明数据被改动了2次，先改为其它，然后又改回到5。</p><p>我再次相信聪明的你已经发现了，这里的CAS其实就是乐观锁，上一种方案里的获取锁和释放锁其实就是悲观锁。乐观锁持乐观态度，就是假设我的数据不会被意外修改，如果修改了，就放弃，从头再来。悲观锁持悲观态度，就是假设我的数据一定会被意外修改，那干脆直接加锁得了。</p><h3 id="作者观点："><a href="#作者观点：" class="headerlink" title="作者观点："></a>作者观点：</h3><p>前两种属于隔离法，一个是位置隔离，一个是数据隔离。</p><p>然后两种是标记法，一个是只读标记，一个是加锁标记。</p><p>最后一种是大胆法，先来怼一把试试，若不行从头再来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转自&lt;a href=&quot;https://mp.weixin.qq.com/s/DJv7h8axGerrmCQFGSpj8Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 编程新说李新杰&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;不是线程的安全&quot;&gt;&lt;a href=&quot;#不是线程的安全&quot; class=&quot;headerlink&quot; title=&quot;不是线程的安全&quot;&gt;&lt;/a&gt;不是线程的安全&lt;/h3&gt;&lt;p&gt;面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。&lt;/p&gt;
&lt;p&gt;论语中有句话叫“学而优则仕”，相信很多人都觉得是“学习好了可以做官”。然而，这样理解却是错的。切记望文生义。&lt;/p&gt;
&lt;p&gt;同理，“线程安全”也不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。&lt;/p&gt;
&lt;p&gt;目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。&lt;/p&gt;
&lt;p&gt;在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。&lt;/p&gt;
&lt;p&gt;假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。&lt;/p&gt;
&lt;p&gt;比如把你住的小区看作一个进程，小区里的道路/绿化等就属于公共区域。你拿1万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。&lt;/p&gt;
&lt;p&gt;因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。&lt;/p&gt;
&lt;p&gt;所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。&lt;/p&gt;
&lt;p&gt;即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程“破坏”。&lt;/p&gt;
&lt;p&gt;那我们该怎么办呢？&lt;strong&gt;&lt;em&gt;解决问题的过程其实就是一个取舍的过程，不同的解决方案有不同的侧重点。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的7种写法</title>
    <link href="http://yoursite.com/2019/04/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%847%E7%A7%8D%E5%86%99%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/28/单例模式的7种写法/</id>
    <published>2019-04-28T08:28:57.000Z</published>
    <updated>2020-01-14T10:12:33.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转自公众号<a href="https://mp.weixin.qq.com/s/zXhvdF9inUDkqwCrrBt_Cg" target="_blank" rel="noopener">无敌码农 | 谁要是再问你单例模式，那就抛给他这7种写法吧！</a></p></blockquote><p>单例设计模式是23种设计模式中，最基础也是最常用的设计模式之一，也是面试中关于设计模式知识点考察比较高频的问题之一。说起单例模式的写法，大多数情况下出现在我们脑海中的可能就是“饿汉式”，“懒汉式”这两种写法，但是今天小码哥今天要介绍的是单例模式的7种写法，以后面试官要是再问你单例模式，那就抛给他这七种写法吧！</p><a id="more"></a><p>接下来，我们就言归正传，来一一介绍这七种单例模式的写法吧！</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式是单例模式设计中比较经典的实现方式。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//final不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonEhangshi</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在定义实例对象时直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTonEhangshi instance = <span class="keyword">new</span> SingleTonEhangshi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造函数，不允许外部NEW</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTonEhangshi</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTonEhangshi <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式的实现关键在于instance作为类变量直接得到了初始化，如果我们主动使用SingleToEhangshi类，那么instance实例将会直接完成创建，包括其中的实例变量也都会得到初始化。</p><p>instance作为类变量，在类初始化的过程中会被收集进&lt;clinit>()方法中，而该方法是可以100%地保证同步，也就是说instance在多线程的情况下不可能被初始化两次。但是由于instance被ClassLoader加载后很长一段时间才被使用的话，那就会意味着instance实例所开辟的堆内存会驻留很长的时间。</p><p>总体说来，如果一个类中的成员变量比较少，且占用的内存资源也不多，用饿汉式的方式实现单例模式也未尝不可，只是其无法进行懒加载。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>所谓懒汉式就是在使用类实例的时候再去创建，也就是说用到的时候我再创建，这样就可以避免类在初始化的时候提前创建过早地占用内存空间。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//final不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonLhangshi</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义实例，但是不直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTonLhangshi instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造函数，不允许外部NEW</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTonLhangshi</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTonLhangshi <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleTonLhangshi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类变量instance=null,因此当类被初始化的时候instance并不会立刻被实例化，而是在getInstance()方法被调用时判断instance实例是否被实例化，如果没有实例化在调用私有构造方法进行实例化操作。</p><p>懒汉式写法在多线程环境下，会存在同一时间多个线程同时看到null==instance的情况，从而导致instance会被实例化多次，从而无法保证单例的唯一性。</p><h3 id="懒汉式＋同步方法"><a href="#懒汉式＋同步方法" class="headerlink" title="懒汉式＋同步方法"></a>懒汉式＋同步方法</h3><p>懒汉式的单例实现方式可以保证实例的懒加载，但是却无法保证实例的唯一性。在多线程环境下由于instance为共享数据，当多个线程访问使用时，需要保证数据的同步性，所以如果需要保证懒汉式实例的唯一性，我们可以通过同步的方式来实现。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//final不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonLhangshiSync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义实例，但是不直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTonLhangshiSync instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造函数，不允许外部NEW</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTonLhangshiSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向getInstance方法加入同步控制，每次只能有一个线程能够进入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleTonLhangshiSync <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleTonLhangshiSync();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采用懒汉式＋数据同步的方法既满足了懒加载又能够100%保证instance实例的唯一性。但是，synchronized关键字的排它性会导致getInstance()方法同一时刻只能被一个线程访问，性能会比较低下。</p><h3 id="Double-Check"><a href="#Double-Check" class="headerlink" title="Double-Check"></a>Double-Check</h3><p>Double-Check是一种比较聪明的设计方式，它提供了一种高效的数据同步策略，那就是首次初始化的时候加锁，之后则允许多个线程同时进行getInstance()方法的调用来获得类的实例。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//final不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDoubleCheck</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义实例，但是不直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDoubleCheck instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Connection con;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造函数，不允许外部NEW</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDoubleCheck</span><span class="params">(Connection con, Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.con = con;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">this</span>.socket = socket;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当instance为null时，进入同步代码块，同时该判断避免了每次都需要进入同步代码块，可以提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">//只有一个线程能够获得SingletonDoubleCheck.class关联的monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDoubleCheck.class) &#123;</span><br><span class="line">                <span class="comment">//判断如果instance为null则创建</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当两个线程发现null==instance成立时，只有一个线程有资格进入同步代码块，完成对instance的初始化，随后的线程发现null==instance不成立则无须进行任何操作，以后对getInstance的访问就不会再需要进行数据同步了。</p><p>此种方式看起来是既满足了懒加载，又保证了instance实例的唯一性，并且还提供了比较高效的数据同步策略，可以允许多个线程同时对getInstance进行访问。但是这种方式在多线程的情况下，可能会引起空指针异常，这是因为如果在如上代码的构造方法中还存在初始化其他资源的情况的话，由于JVM运行时存在指令重排的情况，这些资源在实例化时顺序并无前后关系的约束，那么在这种情况下，就极有可能是instance最先被实例化，而con和socket并未完成实例化，而未完成实例化的实例在调用其方法时将会抛出空指针异常。</p><h3 id="Volatile-Double-Check"><a href="#Volatile-Double-Check" class="headerlink" title="Volatile+Double-Check"></a>Volatile+Double-Check</h3><p>为了解决Double-Check指令重排导致的空指针问题，可以用volatile关键字防止这种重排序的发生。因此代码只需要稍作修改就能满足多线程下的单例、懒加载以及实例的高效性了。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//final不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDoubleCheck</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义实例，但是不直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDoubleCheck instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Connection con;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造函数，不允许外部NEW</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDoubleCheck</span><span class="params">(Connection con, Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.con = con;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">this</span>.socket = socket;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当instance为null时，进入同步代码块，同时该判断避免了每次都需要进入同步代码块，可以提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">//只有一个线程能够获得SingletonDoubleCheck.class关联的monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDoubleCheck.class) &#123;</span><br><span class="line">                <span class="comment">//判断如果instance为null则创建</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Holder方式"><a href="#Holder方式" class="headerlink" title="Holder方式"></a>Holder方式</h3><p>Holder方式完全借助了类加载的特点。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态内部类中持有单例类的实例，并且可直接被初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonHolder instance = <span class="keyword">new</span> SingletonHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用getInstance方法，事实上是获得Holder的instance静态属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在单例类中并没有instance的静态成员，而是将其放到了静态内部类Holder之中，因此单例类在初始化的过程中并不会创建SingletonHolder的实例，内部类Holder中定义了SingletonHolder的静态变量，并且直接进行了实例化，只有当Holder被主动引用的时候才会创建SingletonHolder的实例。</p><p>SingletonHolder实例的创建过程在Java程序编译时期收集至&lt;clinit>()方法中，该方法又是同步方法，可以保证内存的可见性、JVM指令的顺序性和原子性。Holder方式的单例模式设计是最好的设计之一，也是目前使用比较广的设计。</p><h3 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h3><p>枚举方式在很多开源框架中也应用得比较广泛，枚举类型不允许被继承，同样是线程安全的，并且只能被实例化一次，但是枚举类型不能够实现懒加载。用枚举类型，实现单例模式的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用枚举充当Holder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> EnumHolder &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonEnum instance;</span><br><span class="line"></span><br><span class="line">        EnumHolder() &#123;</span><br><span class="line">            <span class="keyword">this</span>.instance = <span class="keyword">new</span> SingletonEnum();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> SingletonEnum <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEnum <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumHolder.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是要给大家介绍的单例模式的7种写法了，虽然单例模式非常简单，但是在多线程的情况下，我们之前所设计的单例程序未必能够满足单实例、懒加载以及高性能的特点。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章转自公众号&lt;a href=&quot;https://mp.weixin.qq.com/s/zXhvdF9inUDkqwCrrBt_Cg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;无敌码农 | 谁要是再问你单例模式，那就抛给他这7种写法吧！&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例设计模式是23种设计模式中，最基础也是最常用的设计模式之一，也是面试中关于设计模式知识点考察比较高频的问题之一。说起单例模式的写法，大多数情况下出现在我们脑海中的可能就是“饿汉式”，“懒汉式”这两种写法，但是今天小码哥今天要介绍的是单例模式的7种写法，以后面试官要是再问你单例模式，那就抛给他这七种写法吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux定时任务</title>
    <link href="http://yoursite.com/2019/04/28/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/04/28/Linux定时任务/</id>
    <published>2019-04-28T08:12:54.000Z</published>
    <updated>2020-01-14T10:12:33.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转自 <a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html" target="_blank" rel="noopener">菜鸟教程</a></p></blockquote><p>inux内置的cron进程能帮我们实现这些需求，cron搭配shell脚本，非常复杂的指令也没有问题。</p><h3 id="cron介绍"><a href="#cron介绍" class="headerlink" title="cron介绍"></a>cron介绍</h3><p>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。</p><ul><li>/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名</li><li>/etc/crontab 这个文件负责调度各种管理和维护任务。</li><li>/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。</li><li>我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。</li></ul><a id="more"></a><h3 id="crontab的使用"><a href="#crontab的使用" class="headerlink" title="crontab的使用"></a>crontab的使用</h3><p>我们常用的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u username]　　　　//省略用户表表示操作当前用户的crontab</span><br><span class="line">    -e      (编辑工作表)</span><br><span class="line">    -l      (列出工作表里的命令)</span><br><span class="line">    -r      (删除工作作)</span><br></pre></td></tr></table></figure><p>我们用 <code>crontab -e</code> 进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。</p><p>crontab的命令构成为 时间+动作，其时间有 <strong>分、时、日、月、周</strong> 五种，操作符有</p><ul><li>* 取值范围内的所有数字</li><li>/ 每过多少个数字</li><li>- 从X到Z</li><li>，散列数字</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="实例1：每1分钟执行一次myCommand"><a href="#实例1：每1分钟执行一次myCommand" class="headerlink" title="实例1：每1分钟执行一次myCommand"></a>实例1：每1分钟执行一次myCommand</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * myCommand</span><br></pre></td></tr></table></figure><h4 id="实例2：每小时的第3和第15分钟执行"><a href="#实例2：每小时的第3和第15分钟执行" class="headerlink" title="实例2：每小时的第3和第15分钟执行"></a>实例2：每小时的第3和第15分钟执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * myCommand</span><br></pre></td></tr></table></figure><h4 id="实例3：在上午8点到11点的第3和第15分钟执行"><a href="#实例3：在上午8点到11点的第3和第15分钟执行" class="headerlink" title="实例3：在上午8点到11点的第3和第15分钟执行"></a>实例3：在上午8点到11点的第3和第15分钟执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * myCommand</span><br></pre></td></tr></table></figure><h4 id="实例4：每隔两天的上午8点到11点的第3和第15分钟执行"><a href="#实例4：每隔两天的上午8点到11点的第3和第15分钟执行" class="headerlink" title="实例4：每隔两天的上午8点到11点的第3和第15分钟执行"></a>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2  *  * myCommand</span><br></pre></td></tr></table></figure><h4 id="实例5：每周一上午8点到11点的第3和第15分钟执行"><a href="#实例5：每周一上午8点到11点的第3和第15分钟执行" class="headerlink" title="实例5：每周一上午8点到11点的第3和第15分钟执行"></a>实例5：每周一上午8点到11点的第3和第15分钟执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 myCommand</span><br></pre></td></tr></table></figure><h4 id="实例6：每晚的21-30重启smb"><a href="#实例6：每晚的21-30重启smb" class="headerlink" title="实例6：每晚的21:30重启smb"></a>实例6：每晚的21:30重启smb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><h4 id="实例7：每月1、10、22日的4-45重启smb"><a href="#实例7：每月1、10、22日的4-45重启smb" class="headerlink" title="实例7：每月1、10、22日的4 : 45重启smb"></a>实例7：每月1、10、22日的4 : 45重启smb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><h4 id="实例8：每周六、周日的1-10重启smb"><a href="#实例8：每周六、周日的1-10重启smb" class="headerlink" title="实例8：每周六、周日的1 : 10重启smb"></a>实例8：每周六、周日的1 : 10重启smb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><h4 id="实例9：每天18-00至23-00之间每隔30分钟重启smb"><a href="#实例9：每天18-00至23-00之间每隔30分钟重启smb" class="headerlink" title="实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb"></a>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><h4 id="实例10：每星期六的晚上11-00-pm重启smb"><a href="#实例10：每星期六的晚上11-00-pm重启smb" class="headerlink" title="实例10：每星期六的晚上11 : 00 pm重启smb"></a>实例10：每星期六的晚上11 : 00 pm重启smb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><h4 id="实例11：每一小时重启smb"><a href="#实例11：每一小时重启smb" class="headerlink" title="实例11：每一小时重启smb"></a>实例11：每一小时重启smb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><h4 id="实例12：晚上11点到早上7点之间，每隔一小时重启smb"><a href="#实例12：晚上11点到早上7点之间，每隔一小时重启smb" class="headerlink" title="实例12：晚上11点到早上7点之间，每隔一小时重启smb"></a>实例12：晚上11点到早上7点之间，每隔一小时重启smb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 23-7/1 * * * /etc/init.d/smb restar</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章转自 &lt;a href=&quot;https://www.runoob.com/w3cnote/linux-crontab-tasks.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;inux内置的cron进程能帮我们实现这些需求，cron搭配shell脚本，非常复杂的指令也没有问题。&lt;/p&gt;
&lt;h3 id=&quot;cron介绍&quot;&gt;&lt;a href=&quot;#cron介绍&quot; class=&quot;headerlink&quot; title=&quot;cron介绍&quot;&gt;&lt;/a&gt;cron介绍&lt;/h3&gt;&lt;p&gt;我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名&lt;/li&gt;
&lt;li&gt;/etc/crontab 这个文件负责调度各种管理和维护任务。&lt;/li&gt;
&lt;li&gt;/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。&lt;/li&gt;
&lt;li&gt;我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Oracle的一些故障处理</title>
    <link href="http://yoursite.com/2019/04/08/Oracle%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/08/Oracle的一些故障处理/</id>
    <published>2019-04-08T05:17:55.000Z</published>
    <updated>2020-01-14T10:12:33.247Z</updated>
    
    <content type="html"><![CDATA[<p>这里汇总了一些在使用Oracle过程中遇到的问题及解决办法，一方面做为笔记帮助自己以后更快速处理问题，一方面分享处理供大家互相学习。</p><a id="more"></a><h3 id="⚪SP2-0667-Message-file-sp1-msb-not-found"><a href="#⚪SP2-0667-Message-file-sp1-msb-not-found" class="headerlink" title="⚪SP2-0667: Message file sp1.msb not found"></a>⚪SP2-0667: Message file sp1<lang>.msb not found</lang></h3><p><img src="TIM20190408103118.png" alt></p><p>出错原因：<br>crontab里面的脚本，通常读取的是默认的环境变量，PATH里面不包含oracle数据库的路径。</p><p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>把一下内容填写其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ORACLE_HOME=/u01/app/oracle/product/11.2.0/dbhome_1</span><br><span class="line">export PATH=$ORACLE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><blockquote><p>注意，ORACLE_HOME的路径要是你计算机中oracle真实的安装地址</p></blockquote><p>环境变量设置完成，执行 <code>source ~/.bashrc</code> 使其生效。</p><p><img src="TIM20190408122029.png" alt></p><h3 id="⚪ORA-12162-TNS-net-service-name-is-incorrectly-specified"><a href="#⚪ORA-12162-TNS-net-service-name-is-incorrectly-specified" class="headerlink" title="⚪ORA-12162: TNS:net service name is incorrectly specified"></a>⚪ORA-12162: TNS:net service name is incorrectly specified</h3><p><img src="TIM20190408121707.png" alt></p><p>一般出现这种错误，基本都是环境变量配置有问题，要么是没有配置正确的ORACLE_SID、ORACLE_HOME，要么是监听配置环境变量和.bash_profile环境变量配置不一致。</p><p>这里检查发现，是操作系统环境变量没有配置ORACLE_SID</p><p><img src="TIM20190408122343.png" alt></p><p>因此，我们配置一下 ~/.bashrc ，在其中添加ORACLE_SID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ORACLE_SID=erp</span><br></pre></td></tr></table></figure><blockquote><p>注意：ORACLE_SID的值要根据自己安装oracle时设置的为准</p></blockquote><p><img src="TIM20190408122811.png" alt></p><p><img src="TIM20190408122556.png" alt></p><h3 id="⚪ORA-04021-timeout-occurred-while-waiting-to-lock-object"><a href="#⚪ORA-04021-timeout-occurred-while-waiting-to-lock-object" class="headerlink" title="⚪ORA-04021: timeout occurred while waiting to lock object"></a>⚪ORA-04021: timeout occurred while waiting to lock object</h3><h4 id="情景描述"><a href="#情景描述" class="headerlink" title="情景描述:"></a>情景描述:</h4><p>Oracle中本来有个用户NC63PM_PEIXUN1，我把这个用户名更改为了NC63PM_PEIXUN2（更改方法请参考<a href="/2019/04/19/Oracle更改用户名和密码">【Oracle更改用户名和密码】</a>），之后我想按照旧的用户名再创建一个用户，但是创建的用户的SQL语句执行了十五分钟还没执行完，并报如下的错误：</p><p><img src="TIM20190420145348.png" alt="ORA-04021: timeout occurred while waiting to lock object"></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>查看是否被锁表了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT object_name,machine,s.sid,s.serial#</span><br><span class="line">&gt; FROM v$locked_object l,dba_objects o ,v$session s</span><br><span class="line">&gt; WHERE l.object_id=o.object_id AND l.session_id=s.sid;</span><br></pre></td></tr></table></figure><p>发现没有被锁表</p><p><img src="TIM20190420145700.png" alt="查看锁表"></p><p>使用 DBA_DDL_LOCKS视图获得DDL锁定信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM dba_ddl_locks;</span><br></pre></td></tr></table></figure><p>发现有两条关于 NC63PM_PEIXUN1 用户的锁定信息</p><p><img src="TIM20190420150236.png" alt></p><p>通过 session_id 找到对应的锁表信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT sid,serial#,status FROM v$session a WHERE a.sid in (829,392);</span><br></pre></td></tr></table></figure><p><img src="TIM20190420150455.png" alt></p><p>注：因我是kill掉这两条信息后才截的图，所以 STATUS 才为 KILLED 的。</p><p>kill这两条锁表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ALTER SYSTEM KILL SESSION &apos;392, 5049&apos;;</span><br><span class="line">&gt; ALTER SYSTEM KILL SESSION &apos;829, 25287&apos;;</span><br></pre></td></tr></table></figure><p>再次执行创建用户的脚本就能顺利执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里汇总了一些在使用Oracle过程中遇到的问题及解决办法，一方面做为笔记帮助自己以后更快速处理问题，一方面分享处理供大家互相学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识小结</title>
    <link href="http://yoursite.com/2019/03/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/26/Java基础知识小结/</id>
    <published>2019-03-26T05:44:17.000Z</published>
    <updated>2020-01-14T10:12:33.231Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章是为了记录一下学习中被忽略的知识点，这些知识点虽然知道听说过，但对它们的概念和作用都很模糊，如果别人问起为什么，自己还真解释不上来，因此做个记录，方便以后回顾以及大家一起学习。</p><a id="more"></a><h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?"></a>一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会默认生成一个不带参数且没有任何执行动作的构造方法。<br><br></p><h3 id="在Java中定义一个不做任何事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做任何事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做任何事且没有参数的构造方法的作用"></a>在Java中定义一个不做任何事且没有参数的构造方法的作用</h3><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则系统会自动调用父类中没有参数的构造方法。当此时父类中只定义了有参数的构造方法而没有定义无参数的构造方法，然后在子类的构造方法中又没有使用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到无参数的构造方法可供执行。所以我们要在父类里加上一个不做任何事且没有参数的构造方法。<br><br></p><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为<code>private</code>则子类就不能重写该方法。<br><br></p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul><li>try块：用于捕获异常。其后可跟零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li><li>catch块： 用于处理try捕获的异常。</li><li>finally块：无论是否捕获或者处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。</li></ul><p>注意，一下几种情况finally块不会被执行：<br>  1.在finally语句块中发生了异常；<br>  2.在前面的代码中用了<code>System.exit()</code>退出；<br>  3.程序所有的线程死亡；<br>  4.关闭CPU。<br><br></p><h3 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final/finally/finalize的区别"></a>final/finally/finalize的区别</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）</p><ul><li>当用final修饰一个类时，表明这个类不能被继承</li><li>当final修饰一个类中的某个方法，这个类的子类不能重写覆盖这个被修饰的类，也就是说子类是不能够存在和父类一模一样的方法。</li><li>final修饰变量，该变量表示常量，只能被赋值一次，赋值后值不能被修改。</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>在异常处理时提供finally块来执行清楚操作。论是否捕获或者处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。</p><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p>是方法名。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除之前做必要的清理工作。这个方法是在垃圾收集器在确定了，被清理对象没有被引用的情况下调用的。</p><p>finalize是在Object类中定义的，因此，所有的类都继承了它。子类可以覆盖finalize()方法，来整理系统资源或者执行其他清理工作。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h4><ul><li>HashMap是基于哈希表的Map接口实现的。</li><li>HashMap底层采用的是Entry数组和链表实现的。</li><li>HashMap是采用key-value形式存储，其中key是可以允许为null，但是只能有一个，并且key不允许重复（如果重复则新值会覆盖旧值）。</li><li>HashMap是线程不安全的。</li><li>HashMap存入的顺序和遍历的顺序可能不一致（无序）。</li><li>HashMap保存数据的时候通过计算key的hash值来决定存储的位置。</li></ul><h4 id="HashMap的工作原理是什么？"><a href="#HashMap的工作原理是什么？" class="headerlink" title="HashMap的工作原理是什么？"></a>HashMap的工作原理是什么？</h4><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。</p><h4 id="HashMap源代码"><a href="#HashMap源代码" class="headerlink" title="HashMap源代码"></a>HashMap源代码</h4><p>要看HashMap的源代码，我们还是从HashMap的构造方法开始一步一步的讲解。</p><blockquote><p>小总结：可以看出HashMap构造的时候会初始化16个容量，并且负载因子是0.75。负载因子是什么呢？我们后面讲。</p></blockquote><p><img src="20190419001.jpg" alt></p><blockquote><p>小总结：这个构造方法没有什么可说的，只是多了些验证。在这里呢？构造方法就算初始化完毕了。</p></blockquote><p>我们知道HashMap最常用的方法也就是put方法了，那么下面我们就着重去探究一下put方法的实现原理，也就是对HashMap的一个透彻理解。</p><p><img src="20190419002.jpg" alt="put方法注释说明"></p><p><img src="20190419003.jpg" alt></p><p>这段代码好好的研读，请仔细往下看：</p><p><strong>第一步：</strong> 直接判断 table==EMPTY_TABLE ，那么这个table是什么呢？看下图：</p><p><img src="20190419004.jpg" alt></p><p>那么这个Entry又是说什么东东呢？</p><p><img src="20190419005.jpg" alt></p><p>这个Entry是Map的一个静态内部类，里面最重要的属性有key、value和next三个属性值，在这里，我想大家已经猜到了，这个key和value是不是我们put的时候的key和value呢？答案是的，这个next又是干嘛用的呢？实际上这个Entry的的数据结构是一个单链表，这个next的属性的值还是这个Entry，表示的是当前的节点的下一个节点是哪个Entry。</p><p>好啦，源代码看到这里，我们知道，在put方法中，直接判断table是否为null，那么很显然到目前为止我们的table肯定是为null的，那么继续看如果table为null则要执行的代码。看下图：</p><p><img src="20190419006.jpg" alt></p><p>哇塞，可以很直观的看到，我们实际上是初始化了一个Entry数组，而我们HashMap中的数据都是保存在了Entry[]里面了。</p><blockquote><p>小总结：HashMap其实就是一个线性的Entry数组，而在Entry这个对象中保存了key和value，至于Entry对象中的next的具体作用是干嘛的，稍等做介绍哦。</p></blockquote><p><strong>第二步：</strong> 判断key是否为null。从这里可以看出，当判断key如果为null的话，并没有抛出什么异常错误，很显然HashMap是支持key为null的。那么就来看看key如果为null，会怎么处理呢？</p><p><img src="20190419007.jpg" alt></p><blockquote><p>小总结：首先去循环遍历这个Entry数组，判断是否有key为null的情况，如果有则新值覆盖掉旧值。如果没有key为null的情况，则hash值为0，数据存储在这个Entry数组的第0个位置，也就是table[0]，具体方法可以查看addEntry方法，在这里呢，我就不再演示了。</p></blockquote><p><strong>第三步：</strong> 通过hash方法对key进行计算hash散列值，并且根据这个散列值查找这个要保存的值应该存储到table这个数组中的哪个索引位置。</p><p><img src="20190419008.jpg" alt></p><p><strong>第四步：</strong> 循环变量这个Entry数组，并且判断是否有重复的元素添加进去。</p><p><img src="20190419009.jpg" alt></p><blockquote><p>小总结：当去变量这个Entry数组的时候，去判断两个Entry对象的key的hash是否相同则仅仅表示它们的存储位置是相同的，然后继续判断两个Entry的key是否相等或者equals是否相等，如果条件都满足，则表示要添加的元素，key已经重复，则直接将新值覆盖掉旧值，并且return返回，一旦条件不满足，则直接将添加的元素添加到Entry对象中。</p></blockquote><p>好啦，这个就是整个HashMap的底层原理。现在有的朋友可能会有产生这样的问题：如果计算的key的hash值相等，但是equals方法不相等，那么计算出来的要存储的位置不就冲突了吗？那么如果保存呢？</p><p>解决：实际上这种担忧是有必要的，因为我们完全有可能就是说计算的key的hash值和另一个key的hash值是相等的，那么这个时候呢，如果key的equals方法又不相等，那么这个时候我要保存的value值应该存储到table中的哪个索引上呢？实际上，这种情况叫做hash冲突，学习过数据结构的朋友应该都知道，解决hash冲突的方法有很多，但是在Java中，解决冲突的办法是采用的是链表来解决的。还记得这个Entry的next属性吗？对了，这个next属性就是用来记录这个链表上的下一个Entry。</p><p><img src="20190419010.jpg" alt></p><blockquote><p>HashMap的内容摘自<a href="http://baijiahao.baidu.com/s?id=1601416041995350500&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1601416041995350500&amp;wfr=spider&amp;for=pc</a></p></blockquote><h3 id="volatile关键字的基本作用和原理"><a href="#volatile关键字的基本作用和原理" class="headerlink" title="volatile关键字的基本作用和原理"></a>volatile关键字的基本作用和原理</h3><p>volatile关键字可以实现线程间的可见性，之所以可以实现这一点，原因在于JVM会保证被volatile修饰的变量，在线程栈中被线程使用时都会主动从共享内存(堆内存/主内存)中以实时的方式同步一次；另一方面，如果线程在工作内存中修改了volatile修饰的变量，也会被JVM要求立马刷新到共享内存中去。因此，即便某个线程修改了该变量，其他线程也可以立马感知到变化从而实现可见性.</p><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章是为了记录一下学习中被忽略的知识点，这些知识点虽然知道听说过，但对它们的概念和作用都很模糊，如果别人问起为什么，自己还真解释不上来，因此做个记录，方便以后回顾以及大家一起学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Oracle存储过程的实现</title>
    <link href="http://yoursite.com/2018/03/03/Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/03/03/Oracle存储过程的实现/</id>
    <published>2018-03-03T07:22:46.000Z</published>
    <updated>2020-01-14T10:12:33.247Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（是否给参数要看该存储过程定义的过程中是否设置了参数）来执行它。</p><a id="more"></a><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>创建一张测试表 <code>students</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> STUDENTS(</span><br><span class="line">  <span class="keyword">id</span>      VARCHAR2(<span class="number">50</span>) <span class="keyword">default</span> sys_guid() <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">name</span>    VARCHAR2(<span class="number">20</span>),</span><br><span class="line">  age     <span class="built_in">NUMBER</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">  school  VARCHAR2(<span class="number">100</span>),</span><br><span class="line">  grade   VARCHAR2(<span class="number">50</span>),</span><br><span class="line">  address VARCHAR2(<span class="number">500</span>),</span><br><span class="line">  remarks VARCHAR2(<span class="number">500</span>),</span><br><span class="line">  ts      <span class="built_in">CHAR</span>(<span class="number">19</span>) <span class="keyword">default</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>插入一条测试数据。当然，也可以插入自己想插入的内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> STUDENTS (<span class="keyword">id</span>, <span class="keyword">name</span>, age, school, grade, address, remarks, ts)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">'8A17DE17428E45D6E0530100007FABEB'</span>, <span class="string">'xiaoming'</span>, <span class="number">20</span>, <span class="string">'Changchun University of Architecture'</span>, <span class="string">'Junior'</span>, <span class="string">'Changchun, Jilin'</span>, <span class="literal">null</span>, <span class="string">'2019-06-12 11:07:57'</span>);</span><br></pre></td></tr></table></figure><h3 id="第一个简单的存储过程"><a href="#第一个简单的存储过程" class="headerlink" title="第一个简单的存储过程"></a>第一个简单的存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> stu_school</span><br><span class="line"><span class="keyword">AS</span> school_name VARCHAR2(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> school <span class="keyword">INTO</span> school_name <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="string">'8A17DE17428E45D6E0530100007FABEB'</span>;</span><br><span class="line">  dbms_output.put_line(school_name);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>执行存储过程，可以在PLSQL对象中看到我们刚才新创建的存储过程，并且没有报错，代表编译成功。</p><p><img src="TIM20190612114117.png" alt="简单的存储过程"></p><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> stu_school();</span><br></pre></td></tr></table></figure><blockquote><p>调用时，”()”是必不可少的，无论是有参数还是无参数</p></blockquote><p>在SQL窗口输出页签中可以看到正确的输出内容</p><p><img src="TIM20190612114535.png" alt="输出"></p><h3 id="四种存储过程"><a href="#四种存储过程" class="headerlink" title="四种存储过程"></a>四种存储过程</h3><p><strong>存储过程有一下四种情况</strong></p><ul><li>无参数存储过程</li><li>仅有输入参数存储过程</li><li>仅有输出参数存储过程</li><li>既有输入又有输出存储过程</li></ul><p>下面将对这四种存储过程分别举例说明</p><h4 id="无参数存储过程"><a href="#无参数存储过程" class="headerlink" title="无参数存储过程"></a>无参数存储过程</h4><p>无参数存储过程就如上面写的那个简单的存储过程，也可以这样写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> stu_school</span><br><span class="line"><span class="keyword">AS</span> school_name students.school%<span class="keyword">TYPE</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> school <span class="keyword">INTO</span> school_name <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="string">'8A17DE17428E45D6E0530100007FABEB'</span>;</span><br><span class="line">  dbms_output.put_line(school_name);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="仅有输入参数存储过程"><a href="#仅有输入参数存储过程" class="headerlink" title="仅有输入参数存储过程"></a>仅有输入参数存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> stu_address(stu_id <span class="keyword">IN</span> students.id%<span class="keyword">TYPE</span>)</span><br><span class="line"><span class="keyword">AS</span> addr students.address%<span class="keyword">TYPE</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> address <span class="keyword">INTO</span> addr <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">ID</span>=stu_id;</span><br><span class="line">  dbms_output.put_line(addr);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> stu_address(<span class="string">'8A17DE17428E45D6E0530100007FABEB'</span>);</span><br></pre></td></tr></table></figure><p><img src="TIM20190612121128.png" alt="仅有输入参数存储过程"></p><h4 id="仅有输出参数存储过程"><a href="#仅有输出参数存储过程" class="headerlink" title="仅有输出参数存储过程"></a>仅有输出参数存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> stu_age(stu_age <span class="keyword">OUT</span> students.age%<span class="keyword">TYPE</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> age <span class="keyword">INTO</span> stu_age <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="string">'8A17DE17428E45D6E0530100007FABEB'</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，此种存储过程不能直接通过call来调用，需要通过一下方式执行</p><blockquote><p>注意，如果通过这种方式执行存储过程，要记得在存储过程中添加输出语句，不然的话，纵然执行成功，也没有结果输出。<br><code>dbms_output.put_line(stu_age);</code></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">stuage students.age%<span class="keyword">TYPE</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  stu_age(stuage);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>或者通过oracle函数调用带有输出参数的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> get_stuage(stuage <span class="keyword">OUT</span> <span class="built_in">NUMBER</span>) <span class="keyword">RETURN</span> <span class="built_in">NUMBER</span> <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  stu_age(stuage);</span><br><span class="line">  RETURN stuage;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>执行函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  stuage students.age%<span class="keyword">TYPE</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  dbms_output.put_line(<span class="string">'return result:'</span> || get_stuage(stuage));</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="既有输入又有输出参数的存储过程"><a href="#既有输入又有输出参数的存储过程" class="headerlink" title="既有输入又有输出参数的存储过程"></a>既有输入又有输出参数的存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> stu_name(stuid <span class="keyword">IN</span> students.id%<span class="keyword">TYPE</span>, stuname <span class="keyword">OUT</span> students.name%<span class="keyword">TYPE</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">NAME</span> <span class="keyword">INTO</span> stuname <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">ID</span>=stuid;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>新建存储函数调用存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> get_stuname(stuid <span class="keyword">IN</span> students.id%<span class="keyword">TYPE</span>, stuname <span class="keyword">OUT</span> students.name%<span class="keyword">TYPE</span>) <span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  stu_name(stuid, stuname);</span><br><span class="line">  RETURN stuname;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>执行函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  stuname students.name%<span class="keyword">TYPE</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  dbms_output.put_line(<span class="string">'The student name is:'</span> || get_stuname(<span class="string">'8A17DE17428E45D6E0530100007FABEB'</span>, stuname));</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="Java调用存储过程"><a href="#Java调用存储过程" class="headerlink" title="Java调用存储过程"></a>Java调用存储过程</h3><h4 id="Java调用仅有输出参数的存储过程"><a href="#Java调用仅有输出参数的存储过程" class="headerlink" title="Java调用仅有输出参数的存储过程"></a>Java调用仅有输出参数的存储过程</h4><p>针对存储过程 <code>stu_age</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> stu_age(stu_age <span class="keyword">OUT</span> students.age%<span class="keyword">TYPE</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> age <span class="keyword">INTO</span> stu_age <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="string">'8A17DE17428E45D6E0530100007FABEB'</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnlyOutputProcedure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(DRVIER);</span><br><span class="line">        Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">        String sql = <span class="string">"&#123;call stu_age(?)&#125;"</span>;</span><br><span class="line">        CallableStatement statement = connection.prepareCall(sql);</span><br><span class="line">        statement.registerOutParameter(<span class="number">1</span>, OracleTypes.NUMBER);</span><br><span class="line">        statement.execute();</span><br><span class="line">        System.out.println(statement.getInt(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java调用既有输入参数又有输出参数的存储过程"><a href="#Java调用既有输入参数又有输出参数的存储过程" class="headerlink" title="Java调用既有输入参数又有输出参数的存储过程"></a>Java调用既有输入参数又有输出参数的存储过程</h4><p>针对存储过程 <code>stu_name</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> stu_name(stuid <span class="keyword">IN</span> students.id%<span class="keyword">TYPE</span>, stuname <span class="keyword">OUT</span> students.name%<span class="keyword">TYPE</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">NAME</span> <span class="keyword">INTO</span> stuname <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">ID</span>=stuid;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InAndOutputProcedure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(DRVIER);</span><br><span class="line">        Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">        String sql = <span class="string">"&#123;call stu_name(?,?)&#125;"</span>;</span><br><span class="line">        CallableStatement statement = connection.prepareCall(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>, <span class="string">"8A17DE17428E45D6E0530100007FABEB"</span>);</span><br><span class="line">        statement.registerOutParameter(<span class="number">2</span>, OracleTypes.VARCHAR);</span><br><span class="line">        statement.execute();</span><br><span class="line">        System.out.println(statement.getString(<span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上是有OUT输出参数的存储过程，Java在调用存储过程后还会获得存储过程返回的参数。那么如果存储过程没有OUT输出参数怎么办？</p></blockquote><h4 id="Java调用仅有输入参数的存储过程"><a href="#Java调用仅有输入参数的存储过程" class="headerlink" title="Java调用仅有输入参数的存储过程"></a>Java调用仅有输入参数的存储过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnlyInputProcedure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(DRVIER);</span><br><span class="line">        Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">        String sql = <span class="string">"&#123;call stu_address(?)&#125;"</span>;</span><br><span class="line">        CallableStatement statement = connection.prepareCall(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>, <span class="string">"8A17DE17428E45D6E0530100007FABEB"</span>);</span><br><span class="line">        statement.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java调用无参的存储过程"><a href="#Java调用无参的存储过程" class="headerlink" title="Java调用无参的存储过程"></a>Java调用无参的存储过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NoParameterProcedure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(DRVIER);</span><br><span class="line">        Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">        String sql = <span class="string">"&#123;call stu_school()&#125;"</span>;</span><br><span class="line">        CallableStatement statement = connection.prepareCall(sql);</span><br><span class="line">        statement.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java调用存储函数"><a href="#Java调用存储函数" class="headerlink" title="Java调用存储函数"></a>Java调用存储函数</h3><p>创建一个存储函数 <code>get_address</code> 调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">function</span> get_address(stuid <span class="keyword">in</span> students.id%<span class="keyword">type</span>) <span class="keyword">return</span> varchar2 <span class="keyword">is</span></span><br><span class="line">stuaddress students.address%<span class="keyword">type</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> address <span class="keyword">into</span> stuaddress <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span>=stuid;</span><br><span class="line">  return stuaddress;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>Java调用存储过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NoParameterProcedure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(DRVIER);</span><br><span class="line">        Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">        String sql = <span class="string">"&#123;?=call get_address(?)&#125;"</span>;</span><br><span class="line">        CallableStatement statement = connection.prepareCall(sql);</span><br><span class="line">        statement.registerOutParameter(<span class="number">1</span>, Types.VARCHAR);</span><br><span class="line">        statement.setString(<span class="number">2</span>, <span class="string">"8A17DE17428E45D6E0530100007FABEB"</span>);</span><br><span class="line">        statement.execute();</span><br><span class="line">        System.out.println(statement.getString(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个关于Oracle存储过程的PPT文档，供大家下载学习<a href="oracle存储过程.ppt">点击下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Oracle存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（是否给参数要看该存储过程定义的过程中是否设置了参数）来执行它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle 存储过程" scheme="http://yoursite.com/tags/Oracle-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2013/07/13/hello-world/"/>
    <id>http://yoursite.com/2013/07/13/hello-world/</id>
    <published>2013-07-13T12:46:25.000Z</published>
    <updated>2020-01-14T10:12:33.262Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hello" scheme="http://yoursite.com/tags/hello/"/>
    
      <category term="world" scheme="http://yoursite.com/tags/world/"/>
    
  </entry>
  
</feed>
