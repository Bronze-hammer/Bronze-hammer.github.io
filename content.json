{"meta":{"title":"徐子辉的个人博客","subtitle":null,"description":null,"author":"xuzh","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2019-01-22T01:00:21.000Z","updated":"2019-01-23T01:15:43.281Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-22T01:00:35.000Z","updated":"2019-01-23T01:16:09.796Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-01-22T00:54:44.000Z","updated":"2019-01-22T00:57:21.422Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"This is a page about me!"}],"posts":[{"title":"重写合同台账（部分）","slug":"重写合同台账（部分）","date":"2019-01-22T11:55:29.000Z","updated":"2019-01-22T12:00:57.813Z","comments":true,"path":"2019/01/22/重写合同台账（部分）/","link":"","permalink":"http://yoursite.com/2019/01/22/重写合同台账（部分）/","excerpt":"重写了部分合并情况的SQL语句原SQL语句由四部分组成，通过 UNION ALL 连接起来，SQL也并没有说明为什么要那样写，所以我根据自己的理解重写了一段SQL","text":"重写了部分合并情况的SQL语句原SQL语句由四部分组成，通过 UNION ALL 连接起来，SQL也并没有说明为什么要那样写，所以我根据自己的理解重写了一段SQL 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465SELECT oo.name 公司, bp.project_name 项目, fcc.vbillcode 合同编码, fcc.vrealcontno 纸质合同编码, fb_ct.name 合同类型, fcc.vcontname 合同名称, fcc2.vcontname 主合同, od.name 经办部门, bs_s.name 合同乙方, bs_f.name 合同甲方, fcc.dbilldate 签订日期, decode(fcc.icontstatus,0,&apos;生效&apos;,1,&apos;未生效&apos;,2,&apos;作废&apos;,3,&apos;冻结&apos;,4,&apos;完成&apos;,5,&apos;中止&apos;,&apos;~&apos;) 合同状态, decode(fcc.icontexecstatus,0,&apos;编制中&apos;,1,&apos;执行中&apos;,2,&apos;修订中&apos;,3,&apos;结算中&apos;,4,&apos;已结算&apos;,&apos;~&apos;) 合同执行状态, decode(fcc.icostsplitstatus,1,&apos;部分拆分&apos;,2,&apos;已拆分&apos;,&apos;~&apos;) 拆分状态, decode(fcc.fstatusflag,-1,&apos;自由&apos;,0,&apos;审批未通过&apos;,1,&apos;审批通过&apos;,2,&apos;审批进行中&apos;,3,&apos;提交&apos;,&apos;~&apos;) 单据状态, fcc.ngpcontsignmny 合同签订金额原币, fcc.norigcontsignmny 合同签订金额, fcc.norigmaincontsnmny 主合同签订金额, fcc.norigctsumcostmny 合同总成本金额, fccs.vbillcode 结算单号, fccs.ngpctstlcstmny 合同结算金额原币, fccs.ngpctstlmny 合同结算金额, fccs.norigctstlcstmny 结算成本金额, nvl(fccb.norigcostmny,0) 合同动态成本金额, d.allapprmny 累计已申请金额, d.ngpallappmny 累计已申请金额原币, (nvl(fcc.norigcontsignmny,0) - nvl(fcc.norigrealapplymny,0)) 未申请金额, (nvl(fcc.ngpcontsignmny,0) - nvl(fcc.ngprealapplymny,0)) 未申请金额原币, fbc.name 核算对象, decode(nvl(fccb.vdef10,&apos;~&apos;),&apos;~&apos;,&apos;&apos;,&apos;Y&apos;,&apos;是&apos;,&apos;否&apos;) 是否公摊核算对象, bp_b.project_name 拆分项目, rf.dispname 成本科目, fccb.norigcostmny 拆分金额FROM fdcpm_cm_contract fcc LEFT JOIN org_orgs oo ON oo.pk_org=fcc.pk_org AND NVL(oo.dr,0)=0 LEFT JOIN bd_project bp ON bp.pk_project=fcc.vprojectname AND NVL(bp.dr,0)=0 LEFT JOIN fdcpm_bd_conttype fb_ct ON fb_ct.pk_conttype=fcc.pk_conttype AND NVL(fb_ct.dr,0)=0 LEFT JOIN fdcpm_cm_contract fcc2 ON fcc2.pk_cont=fcc.pk_maincont AND NVL(fcc2.dr,0)=0 LEFT JOIN org_dept od ON od.pk_dept=fcc.pk_dept AND NVL(od.dr,0)=0 LEFT JOIN bd_supplier bs_f ON bs_f.pk_supplier=fcc.pk_first AND NVL(bs_f.dr,0)=0 LEFT JOIN bd_supplier bs_s ON bs_s.pk_supplier=fcc.pk_second AND NVL(bs_s.dr,0)=0 LEFT JOIN fdcpm_cm_contsettle fccs ON fccs.pk_cont=fcc.pk_cont AND NVL(fccs.dr,0)=0 LEFT JOIN fdcpm_cm_costelem_b fccb ON fccb.pk_cont=fcc.pk_cont AND NVL(fccb.dr,0)=0 LEFT JOIN( SELECT fpdt.pk_cont, fcc.vcontname, SUM(NVL(fpdt.norigcontplanmny,0)) norigcontplanmny, SUM(NVL(fpdt.norigthisapplymny,0)) allapprmny, SUM(NVL(DECODE(fpdt.vbdef1,&apos;~&apos;,&apos;0&apos;,fpdt.vbdef1,to_number(fpdt.vbdef1)),0)) ngpallappmny FROM fdcpm_cm_contract fcc LEFT JOIN fdcpm_pay_apply fpa on fpa.pk_contract=fcc.pk_cont LEFT JOIN fdcpm_pay_detail fpdt on fpdt.pk_apply=fpa.pk_apply WHERE NVL(fcc.dr,0)=0 AND NVL(fpa.dr,0)=0 AND NVL(fpdt.dr,0)=0 GROUP BY fpdt.pk_cont,fcc.vcontname ) d ON d.pk_cont=fcc.pk_cont LEFT JOIN fdcpub_bd_cbs fbc ON fbc.pk_cbs=fccb.pk_checkproject AND NVL(fbc.dr,0)=0 LEFT JOIN bd_project bp_b ON bp_b.pk_project=fccb.pk_project AND NVL(bp_b.dr,0)=0 LEFT JOIN resa_factorasoa rf ON rf.pk_factorasoa=fccb.pk_elem AND NVL(rf.dr,0)=0WHERE NVL(fcc.dr,0)=0AND (fcc.icostsplitstatus &lt;&gt; 0) AND fcc.fstatusflag IN (-1,1,2,3) AND fcc.icontexecstatus NOT IN (3,4)AND oo.pk_org=&apos;00015A1000000002HAK2&apos; AND bp.pk_project=&apos;10015A1000000003N9BO&apos;;`","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"通过SQL修改报表模板","slug":"通过SQL修改报表模板","date":"2019-01-22T09:03:12.000Z","updated":"2019-01-23T02:46:50.320Z","comments":true,"path":"2019/01/22/通过SQL修改报表模板/","link":"","permalink":"http://yoursite.com/2019/01/22/通过SQL修改报表模板/","excerpt":"本文档为工作随笔，所以请大家略过 报表模板数据表为 pub_report_templet 通过报表编码查询报表的主体内容 1SELECT * FROM pub_report_templet WHERE NVL(dr,0)=0;","text":"本文档为工作随笔，所以请大家略过 报表模板数据表为 pub_report_templet 通过报表编码查询报表的主体内容 1SELECT * FROM pub_report_templet WHERE NVL(dr,0)=0; parent_code 字段为报表的编码字段 可根据 pk_templet 字段查出报表的所有列，并对所有列进行操作 1SELECT * FROM pub_report_model WHERE pk_templet=&apos;1001Z31000000000YC41&apos; AND NVL(dr,0)=0;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"},{"name":"NC报表","slug":"NC报表","permalink":"http://yoursite.com/tags/NC报表/"}]},{"title":"Oracle去重而保存时间最新的数据","slug":"Oracle去重而保存时间最新的数据","date":"2019-01-21T02:03:52.000Z","updated":"2019-01-23T09:47:32.267Z","comments":true,"path":"2019/01/21/Oracle去重而保存时间最新的数据/","link":"","permalink":"http://yoursite.com/2019/01/21/Oracle去重而保存时间最新的数据/","excerpt":"Oracle去重而保存时间最新的数据 本篇文章仅仅是我工作上的一个随笔记录，写的不是很详细，如果不了解我所做的工作的业务内容，可能会看的一头雾水。大家可以仅做为一种参考思路！ 场景描述： 单据表 fdcpm_pay_apply 中的财务处理状态的值一直是从财务中间表 mid_fina_x 中获取的现在我们在 fdcpm_pay_apply 中添加一个 ifinastatus 的字段用来直接存储财务处理状态的值，并且以后就按照这种方式存储，所以需要把财务中间表中已有的财务处理状态给刷到对应单据的 ifinastatus字段中。 查看表中重复的数据有哪些(去掉重复，只显示单据编码vbillcode)1SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1; 通过上步查询出来的vbillcode，可以查询出所有重复的数据123SELECT * FROM mid_fina WHERE NVL(dr,0)=0 AND vbillcode IN( SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1);","text":"Oracle去重而保存时间最新的数据 本篇文章仅仅是我工作上的一个随笔记录，写的不是很详细，如果不了解我所做的工作的业务内容，可能会看的一头雾水。大家可以仅做为一种参考思路！ 场景描述： 单据表 fdcpm_pay_apply 中的财务处理状态的值一直是从财务中间表 mid_fina_x 中获取的现在我们在 fdcpm_pay_apply 中添加一个 ifinastatus 的字段用来直接存储财务处理状态的值，并且以后就按照这种方式存储，所以需要把财务中间表中已有的财务处理状态给刷到对应单据的 ifinastatus字段中。 查看表中重复的数据有哪些(去掉重复，只显示单据编码vbillcode)1SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1; 通过上步查询出来的vbillcode，可以查询出所有重复的数据123SELECT * FROM mid_fina WHERE NVL(dr,0)=0 AND vbillcode IN( SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1); 那么我们为了以防万一，复制一张一模一样的表来进行下一步的处理1CREATE TABLE mid_fina_x AS (SELECT * FROM mid_fina WHERE NVL(dr,0)=0); 查询数据中vbillcode相等，但是修改时间比较早的数据123SELECT * FROM mid_fina_x mf WHERE mf.ts &lt; ( SELECT MAX(mx.ts) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 删除这些重复数据中的旧数据，只保留最新的那一条123DELETE FROM mid_fina_x mf WHERE mf.ts &lt; ( SELECT MAX(mx.ts) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 需要注意的是，按上述方法删除重复数据，只会删除时间比最新时间早的数据，如果有两条数据，他们的vbillcode和ts修改时间都是一样的，那么这两条数据都不会被删除，因此我们需要再次过来一次重复数据 前一次过滤是通过ts修改时间，那么这次我们可以选择其他有序的字段进行过滤，毕竟，如果几条数据的vbillcode和ts修改时间都相同的情况下，我们只需要取其中的某一条（不管那一条）数据的paystatus财务处理状态的值 123DELETE FROM mid_fina_x mf WHERE mf.pk_pa_payrefinfo &lt; ( SELECT MAX(mx.pk_pa_payrefinfo) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 那么我们现在得到的 mid_fina_x 表就是没有重复数据的数据表了。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"java调用httpservler接口","slug":"java调用httpservler接口","date":"2019-01-18T10:28:00.000Z","updated":"2019-01-21T07:01:05.735Z","comments":true,"path":"2019/01/18/java调用httpservler接口/","link":"","permalink":"http://yoursite.com/2019/01/18/java调用httpservler接口/","excerpt":"写了一个简单的方法测试调用HttpServlet接口","text":"写了一个简单的方法测试调用HttpServlet接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void testHttpPost() &#123; Date date = new Date(); String requestUrl = \"http://ip_address/servlet/~rfffp/nc.rfffp.baseconfig.pub.servlet.CheckContractRefenForErpServlet\"; String userid=\"10015A1000000009QPTF\"; String dataSource = \"nc63pm\"; String billcode = \"G1-HO18120009\"; byte[] parameter = (\"&#123;queryCode:\\\"1\\\",userid:\\\"\"+userid+\"\\\",dataSource:\\\"\"+dataSource+\"\\\",pk_group:\\\"0001A21000000000370V\\\",contractCode:\\\"\"+billcode+\"\\\"&#125;\") .getBytes(); String para = new String(parameter); try &#123; String timestamp = String.valueOf(date.getTime()/1000); URL url = new URL(requestUrl); URLConnection http_url_connection = url.openConnection(); HttpURLConnection HttpUrlConnection = (HttpURLConnection) http_url_connection; HttpUrlConnection.setDoOutput(true); HttpUrlConnection.setDoInput(true); HttpUrlConnection.setRequestMethod(\"POST\");//设置请求方式。可以是delete put post get HttpUrlConnection.setRequestProperty(\"Content-Length\", String.valueOf(parameter.length));//设置内容的长度 HttpUrlConnection.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\");//设置编码格式 HttpUrlConnection.setRequestProperty(\"accept\", \"application/json\");//设置接收返回参数格式 HttpUrlConnection.setRequestProperty(\"timestamp\",timestamp); HttpUrlConnection.setUseCaches(false); BufferedOutputStream output_stream = new BufferedOutputStream(HttpUrlConnection.getOutputStream()); output_stream.write(parameter); output_stream.flush(); output_stream.close(); output_stream = null; InputStreamReader input_stream_reader = new InputStreamReader(HttpUrlConnection.getInputStream(), \"utf-8\"); BufferedReader buffered_reader = new BufferedReader(input_stream_reader); String line; StringBuffer buffer = new StringBuffer(); while ((line = buffered_reader.readLine()) != null) &#123; buffer.append(line); &#125; System.out.println(buffer.toString()); System.out.println(para); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://yoursite.com/categories/汇编语言/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"httpservlet","slug":"httpservlet","permalink":"http://yoursite.com/tags/httpservlet/"}]},{"title":"Oracle触发器的实现","slug":"Oracle触发器的实现","date":"2019-01-03T10:20:15.000Z","updated":"2019-01-22T02:19:31.210Z","comments":true,"path":"2019/01/03/Oracle触发器的实现/","link":"","permalink":"http://yoursite.com/2019/01/03/Oracle触发器的实现/","excerpt":"工作中又遇到这样的问题： 一张表pm_cm_payapply中的vreserve14字段，总是不知道在哪步操作中被致为空（原来的值不为空） 于是打算在表中设置一个触发器 触发器实现： 当表被更新时，判断如果vreserve14被更新为空值，则提示报错","text":"工作中又遇到这样的问题： 一张表pm_cm_payapply中的vreserve14字段，总是不知道在哪步操作中被致为空（原来的值不为空） 于是打算在表中设置一个触发器 触发器实现： 当表被更新时，判断如果vreserve14被更新为空值，则提示报错 触发器内容： 1234567891011CREATE OR REPLACE TRIGGER tri_vreserveAFTER UPDATE OF vreserve14 ON pm_pa_payapplyDECLARE myexp exceptionBEGIN IF old.vreserve14 != &apos;&apos; AND new.vreserve14 == &apos;&apos; THEN RAISE myexp; END IF; EXCEPTION_INIT WHEN myexp THEN raise_application_error(&apos;-20002&apos;,&apos;vreserve14字段的值被设置为空&apos;)；END; 测试： oracle查询触发器 首先我们要知道这个触发器是指向哪个表，比如我们本次是在表 pm_cm_payapply 中写的触发器，那我在 all_trigger 表中通过表明table_name查询触发器名trigger_name 1select trigger_name from all_triggers where table_name=&apos;PM_PA_PAYAPPLY&apos;; 注意，表名要大写 得到触发器名为 tri_vreserve ，再通过触发器名在表all_source 表中查询触发器的具体内容 1select text from all_source where type=&apos;TRIGGER&apos; AND name=&apos;TRI_VRESERVE&apos;; 注意，触发器表名也要大写","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle 触发器","slug":"Oracle-触发器","permalink":"http://yoursite.com/tags/Oracle-触发器/"}]},{"title":"Hello World","slug":"hello-world","date":"2013-07-13T12:46:25.000Z","updated":"2019-01-21T07:55:35.586Z","comments":true,"path":"2013/07/13/hello-world/","link":"","permalink":"http://yoursite.com/2013/07/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"},{"name":"world","slug":"world","permalink":"http://yoursite.com/tags/world/"}]}]}