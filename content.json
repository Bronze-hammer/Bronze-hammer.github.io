{"meta":{"title":"徐子辉的个人站点","subtitle":null,"description":null,"author":"xuzh","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-01-22T00:54:44.000Z","updated":"2019-01-22T00:57:21.422Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"This is a page about me!"},{"title":"categories","date":"2019-01-22T01:00:35.000Z","updated":"2019-01-23T01:16:09.796Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-22T01:00:21.000Z","updated":"2019-01-23T01:15:43.281Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"重写合同台账（部分）","slug":"重写合同台账（部分）","date":"2019-01-22T11:55:29.000Z","updated":"2019-01-22T12:00:57.813Z","comments":true,"path":"2019/01/22/重写合同台账（部分）/","link":"","permalink":"http://yoursite.com/2019/01/22/重写合同台账（部分）/","excerpt":"重写了部分合并情况的SQL语句原SQL语句由四部分组成，通过 UNION ALL 连接起来，SQL也并没有说明为什么要那样写，所以我根据自己的理解重写了一段SQL","text":"重写了部分合并情况的SQL语句原SQL语句由四部分组成，通过 UNION ALL 连接起来，SQL也并没有说明为什么要那样写，所以我根据自己的理解重写了一段SQL 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465SELECT oo.name 公司, bp.project_name 项目, fcc.vbillcode 合同编码, fcc.vrealcontno 纸质合同编码, fb_ct.name 合同类型, fcc.vcontname 合同名称, fcc2.vcontname 主合同, od.name 经办部门, bs_s.name 合同乙方, bs_f.name 合同甲方, fcc.dbilldate 签订日期, decode(fcc.icontstatus,0,&apos;生效&apos;,1,&apos;未生效&apos;,2,&apos;作废&apos;,3,&apos;冻结&apos;,4,&apos;完成&apos;,5,&apos;中止&apos;,&apos;~&apos;) 合同状态, decode(fcc.icontexecstatus,0,&apos;编制中&apos;,1,&apos;执行中&apos;,2,&apos;修订中&apos;,3,&apos;结算中&apos;,4,&apos;已结算&apos;,&apos;~&apos;) 合同执行状态, decode(fcc.icostsplitstatus,1,&apos;部分拆分&apos;,2,&apos;已拆分&apos;,&apos;~&apos;) 拆分状态, decode(fcc.fstatusflag,-1,&apos;自由&apos;,0,&apos;审批未通过&apos;,1,&apos;审批通过&apos;,2,&apos;审批进行中&apos;,3,&apos;提交&apos;,&apos;~&apos;) 单据状态, fcc.ngpcontsignmny 合同签订金额原币, fcc.norigcontsignmny 合同签订金额, fcc.norigmaincontsnmny 主合同签订金额, fcc.norigctsumcostmny 合同总成本金额, fccs.vbillcode 结算单号, fccs.ngpctstlcstmny 合同结算金额原币, fccs.ngpctstlmny 合同结算金额, fccs.norigctstlcstmny 结算成本金额, nvl(fccb.norigcostmny,0) 合同动态成本金额, d.allapprmny 累计已申请金额, d.ngpallappmny 累计已申请金额原币, (nvl(fcc.norigcontsignmny,0) - nvl(fcc.norigrealapplymny,0)) 未申请金额, (nvl(fcc.ngpcontsignmny,0) - nvl(fcc.ngprealapplymny,0)) 未申请金额原币, fbc.name 核算对象, decode(nvl(fccb.vdef10,&apos;~&apos;),&apos;~&apos;,&apos;&apos;,&apos;Y&apos;,&apos;是&apos;,&apos;否&apos;) 是否公摊核算对象, bp_b.project_name 拆分项目, rf.dispname 成本科目, fccb.norigcostmny 拆分金额FROM fdcpm_cm_contract fcc LEFT JOIN org_orgs oo ON oo.pk_org=fcc.pk_org AND NVL(oo.dr,0)=0 LEFT JOIN bd_project bp ON bp.pk_project=fcc.vprojectname AND NVL(bp.dr,0)=0 LEFT JOIN fdcpm_bd_conttype fb_ct ON fb_ct.pk_conttype=fcc.pk_conttype AND NVL(fb_ct.dr,0)=0 LEFT JOIN fdcpm_cm_contract fcc2 ON fcc2.pk_cont=fcc.pk_maincont AND NVL(fcc2.dr,0)=0 LEFT JOIN org_dept od ON od.pk_dept=fcc.pk_dept AND NVL(od.dr,0)=0 LEFT JOIN bd_supplier bs_f ON bs_f.pk_supplier=fcc.pk_first AND NVL(bs_f.dr,0)=0 LEFT JOIN bd_supplier bs_s ON bs_s.pk_supplier=fcc.pk_second AND NVL(bs_s.dr,0)=0 LEFT JOIN fdcpm_cm_contsettle fccs ON fccs.pk_cont=fcc.pk_cont AND NVL(fccs.dr,0)=0 LEFT JOIN fdcpm_cm_costelem_b fccb ON fccb.pk_cont=fcc.pk_cont AND NVL(fccb.dr,0)=0 LEFT JOIN( SELECT fpdt.pk_cont, fcc.vcontname, SUM(NVL(fpdt.norigcontplanmny,0)) norigcontplanmny, SUM(NVL(fpdt.norigthisapplymny,0)) allapprmny, SUM(NVL(DECODE(fpdt.vbdef1,&apos;~&apos;,&apos;0&apos;,fpdt.vbdef1,to_number(fpdt.vbdef1)),0)) ngpallappmny FROM fdcpm_cm_contract fcc LEFT JOIN fdcpm_pay_apply fpa on fpa.pk_contract=fcc.pk_cont LEFT JOIN fdcpm_pay_detail fpdt on fpdt.pk_apply=fpa.pk_apply WHERE NVL(fcc.dr,0)=0 AND NVL(fpa.dr,0)=0 AND NVL(fpdt.dr,0)=0 GROUP BY fpdt.pk_cont,fcc.vcontname ) d ON d.pk_cont=fcc.pk_cont LEFT JOIN fdcpub_bd_cbs fbc ON fbc.pk_cbs=fccb.pk_checkproject AND NVL(fbc.dr,0)=0 LEFT JOIN bd_project bp_b ON bp_b.pk_project=fccb.pk_project AND NVL(bp_b.dr,0)=0 LEFT JOIN resa_factorasoa rf ON rf.pk_factorasoa=fccb.pk_elem AND NVL(rf.dr,0)=0WHERE NVL(fcc.dr,0)=0AND (fcc.icostsplitstatus &lt;&gt; 0) AND fcc.fstatusflag IN (-1,1,2,3) AND fcc.icontexecstatus NOT IN (3,4)AND oo.pk_org=&apos;00015A1000000002HAK2&apos; AND bp.pk_project=&apos;10015A1000000003N9BO&apos;;`","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"通过SQL修改报表模板","slug":"通过SQL修改报表模板","date":"2019-01-22T09:03:12.000Z","updated":"2019-01-23T02:46:50.320Z","comments":true,"path":"2019/01/22/通过SQL修改报表模板/","link":"","permalink":"http://yoursite.com/2019/01/22/通过SQL修改报表模板/","excerpt":"本文档为工作随笔，所以请大家略过 报表模板数据表为 pub_report_templet 通过报表编码查询报表的主体内容 1SELECT * FROM pub_report_templet WHERE NVL(dr,0)=0;","text":"本文档为工作随笔，所以请大家略过 报表模板数据表为 pub_report_templet 通过报表编码查询报表的主体内容 1SELECT * FROM pub_report_templet WHERE NVL(dr,0)=0; parent_code 字段为报表的编码字段 可根据 pk_templet 字段查出报表的所有列，并对所有列进行操作 1SELECT * FROM pub_report_model WHERE pk_templet=&apos;1001Z31000000000YC41&apos; AND NVL(dr,0)=0;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"},{"name":"NC报表","slug":"NC报表","permalink":"http://yoursite.com/tags/NC报表/"}]},{"title":"Oracle去重而保存时间最新的数据","slug":"Oracle去重而保存时间最新的数据","date":"2019-01-21T02:03:52.000Z","updated":"2019-01-23T09:47:32.267Z","comments":true,"path":"2019/01/21/Oracle去重而保存时间最新的数据/","link":"","permalink":"http://yoursite.com/2019/01/21/Oracle去重而保存时间最新的数据/","excerpt":"Oracle去重而保存时间最新的数据 本篇文章仅仅是我工作上的一个随笔记录，写的不是很详细，如果不了解我所做的工作的业务内容，可能会看的一头雾水。大家可以仅做为一种参考思路！ 场景描述： 单据表 fdcpm_pay_apply 中的财务处理状态的值一直是从财务中间表 mid_fina_x 中获取的现在我们在 fdcpm_pay_apply 中添加一个 ifinastatus 的字段用来直接存储财务处理状态的值，并且以后就按照这种方式存储，所以需要把财务中间表中已有的财务处理状态给刷到对应单据的 ifinastatus字段中。 查看表中重复的数据有哪些(去掉重复，只显示单据编码vbillcode)1SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1; 通过上步查询出来的vbillcode，可以查询出所有重复的数据123SELECT * FROM mid_fina WHERE NVL(dr,0)=0 AND vbillcode IN( SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1);","text":"Oracle去重而保存时间最新的数据 本篇文章仅仅是我工作上的一个随笔记录，写的不是很详细，如果不了解我所做的工作的业务内容，可能会看的一头雾水。大家可以仅做为一种参考思路！ 场景描述： 单据表 fdcpm_pay_apply 中的财务处理状态的值一直是从财务中间表 mid_fina_x 中获取的现在我们在 fdcpm_pay_apply 中添加一个 ifinastatus 的字段用来直接存储财务处理状态的值，并且以后就按照这种方式存储，所以需要把财务中间表中已有的财务处理状态给刷到对应单据的 ifinastatus字段中。 查看表中重复的数据有哪些(去掉重复，只显示单据编码vbillcode)1SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1; 通过上步查询出来的vbillcode，可以查询出所有重复的数据123SELECT * FROM mid_fina WHERE NVL(dr,0)=0 AND vbillcode IN( SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1); 那么我们为了以防万一，复制一张一模一样的表来进行下一步的处理1CREATE TABLE mid_fina_x AS (SELECT * FROM mid_fina WHERE NVL(dr,0)=0); 查询数据中vbillcode相等，但是修改时间比较早的数据123SELECT * FROM mid_fina_x mf WHERE mf.ts &lt; ( SELECT MAX(mx.ts) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 删除这些重复数据中的旧数据，只保留最新的那一条123DELETE FROM mid_fina_x mf WHERE mf.ts &lt; ( SELECT MAX(mx.ts) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 需要注意的是，按上述方法删除重复数据，只会删除时间比最新时间早的数据，如果有两条数据，他们的vbillcode和ts修改时间都是一样的，那么这两条数据都不会被删除，因此我们需要再次过来一次重复数据 前一次过滤是通过ts修改时间，那么这次我们可以选择其他有序的字段进行过滤，毕竟，如果几条数据的vbillcode和ts修改时间都相同的情况下，我们只需要取其中的某一条（不管那一条）数据的paystatus财务处理状态的值 123DELETE FROM mid_fina_x mf WHERE mf.pk_pa_payrefinfo &lt; ( SELECT MAX(mx.pk_pa_payrefinfo) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 那么我们现在得到的 mid_fina_x 表就是没有重复数据的数据表了。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"java调用httpservler接口","slug":"java调用httpservler接口","date":"2019-01-18T10:28:00.000Z","updated":"2019-01-21T07:01:05.735Z","comments":true,"path":"2019/01/18/java调用httpservler接口/","link":"","permalink":"http://yoursite.com/2019/01/18/java调用httpservler接口/","excerpt":"写了一个简单的方法测试调用HttpServlet接口","text":"写了一个简单的方法测试调用HttpServlet接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void testHttpPost() &#123; Date date = new Date(); String requestUrl = \"http://ip_address/servlet/~rfffp/nc.rfffp.baseconfig.pub.servlet.CheckContractRefenForErpServlet\"; String userid=\"10015A1000000009QPTF\"; String dataSource = \"nc63pm\"; String billcode = \"G1-HO18120009\"; byte[] parameter = (\"&#123;queryCode:\\\"1\\\",userid:\\\"\"+userid+\"\\\",dataSource:\\\"\"+dataSource+\"\\\",pk_group:\\\"0001A21000000000370V\\\",contractCode:\\\"\"+billcode+\"\\\"&#125;\") .getBytes(); String para = new String(parameter); try &#123; String timestamp = String.valueOf(date.getTime()/1000); URL url = new URL(requestUrl); URLConnection http_url_connection = url.openConnection(); HttpURLConnection HttpUrlConnection = (HttpURLConnection) http_url_connection; HttpUrlConnection.setDoOutput(true); HttpUrlConnection.setDoInput(true); HttpUrlConnection.setRequestMethod(\"POST\");//设置请求方式。可以是delete put post get HttpUrlConnection.setRequestProperty(\"Content-Length\", String.valueOf(parameter.length));//设置内容的长度 HttpUrlConnection.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\");//设置编码格式 HttpUrlConnection.setRequestProperty(\"accept\", \"application/json\");//设置接收返回参数格式 HttpUrlConnection.setRequestProperty(\"timestamp\",timestamp); HttpUrlConnection.setUseCaches(false); BufferedOutputStream output_stream = new BufferedOutputStream(HttpUrlConnection.getOutputStream()); output_stream.write(parameter); output_stream.flush(); output_stream.close(); output_stream = null; InputStreamReader input_stream_reader = new InputStreamReader(HttpUrlConnection.getInputStream(), \"utf-8\"); BufferedReader buffered_reader = new BufferedReader(input_stream_reader); String line; StringBuffer buffer = new StringBuffer(); while ((line = buffered_reader.readLine()) != null) &#123; buffer.append(line); &#125; System.out.println(buffer.toString()); System.out.println(para); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://yoursite.com/categories/汇编语言/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"httpservlet","slug":"httpservlet","permalink":"http://yoursite.com/tags/httpservlet/"}]},{"title":"Oracle触发器的实现","slug":"Oracle触发器的实现","date":"2019-01-03T10:20:15.000Z","updated":"2019-03-03T07:20:48.092Z","comments":true,"path":"2019/01/03/Oracle触发器的实现/","link":"","permalink":"http://yoursite.com/2019/01/03/Oracle触发器的实现/","excerpt":"触发器的定义就是说某个条件成立的时候，触发器里面所定义的语句就会被自动的执行。因此触发器不需要人为的去调用，也不能调用。触发器分为语句级触发器和行级触发器。语句级触发器可以在某些语句执行前或者执行后触发，而行级触发器是定义指定表中行数据改变时的触发器。","text":"触发器的定义就是说某个条件成立的时候，触发器里面所定义的语句就会被自动的执行。因此触发器不需要人为的去调用，也不能调用。触发器分为语句级触发器和行级触发器。语句级触发器可以在某些语句执行前或者执行后触发，而行级触发器是定义指定表中行数据改变时的触发器。 工作中又遇到这样的问题： 一张表pm_cm_payapply中的vreserve14字段，总是不知道在哪步操作中被致为空（原来的值不为空） 于是打算在表中设置一个触发器 触发器实现： 当表被更新时，判断如果vreserve14被更新为空值，则提示报错 触发器内容： 1234567891011CREATE OR REPLACE TRIGGER tri_vreserveAFTER UPDATE OF vreserve14 ON pm_pa_payapplyDECLARE myexp exceptionBEGIN IF old.vreserve14 != &apos;&apos; AND new.vreserve14 == &apos;&apos; THEN RAISE myexp; END IF; EXCEPTION_INIT WHEN myexp THEN raise_application_error(&apos;-20002&apos;,&apos;vreserve14字段的值被设置为空&apos;)；END; 测试： oracle查询触发器 首先我们要知道这个触发器是指向哪个表，比如我们本次是在表 pm_cm_payapply 中写的触发器，那我在 all_trigger 表中通过表明table_name查询触发器名trigger_name 1select trigger_name from all_triggers where table_name=&apos;PM_PA_PAYAPPLY&apos;; 注意，表名要大写 得到触发器名为 tri_vreserve ，再通过触发器名在表all_source 表中查询触发器的具体内容 1select text from all_source where type=&apos;TRIGGER&apos; AND name=&apos;TRI_VRESERVE&apos;; 注意，触发器表名也要大写","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle 触发器","slug":"Oracle-触发器","permalink":"http://yoursite.com/tags/Oracle-触发器/"}]},{"title":"Oracle存储过程的实现","slug":"Oracle存储过程的实现","date":"2018-03-03T07:22:46.000Z","updated":"2019-03-03T07:34:57.782Z","comments":true,"path":"2018/03/03/Oracle存储过程的实现/","link":"","permalink":"http://yoursite.com/2018/03/03/Oracle存储过程的实现/","excerpt":"Oracle存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（是否给参数要看该存储过程定义的过程中是否设置了参数）来执行它。","text":"Oracle存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（是否给参数要看该存储过程定义的过程中是否设置了参数）来执行它。 这里有一个关于Oracle存储过程的PPT文档，供大家下载学习点击下载","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle 存储过程","slug":"Oracle-存储过程","permalink":"http://yoursite.com/tags/Oracle-存储过程/"}]},{"title":"Linux的ps命令解析","slug":"Linux的ps命令解析","date":"2018-03-01T08:23:30.000Z","updated":"2019-03-03T07:13:31.595Z","comments":true,"path":"2018/03/01/Linux的ps命令解析/","link":"","permalink":"http://yoursite.com/2018/03/01/Linux的ps命令解析/","excerpt":"Linux的ps命令解析Linux ps命令用于显示当前进程 (process) 的状态。要对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程,ps命令就是最基本进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到。ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。","text":"Linux的ps命令解析Linux ps命令用于显示当前进程 (process) 的状态。要对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程,ps命令就是最基本进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到。ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。 列出目前所有的正在内存当中的程序输入命令 1# ps aux USER：该进程属于那个使用者账号。 PID ：该进程的进程ID号。 %CPU：该进程使用掉的 CPU 资源百分比； %MEM：该进程所占用的物理内存百分比； VSZ ：该进程使用掉的虚拟内存量 (Kbytes) RSS ：该进程占用的固定的内存量 (Kbytes) TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示 ?。另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有： R ：该程序目前正在运作，或者是可被运作； S ：该程序目前正在睡眠当中，但可被某些讯号(signal) 唤醒。 T ：该程序目前正在侦测或者是停止了； Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态 START：该进程被触发启动的时间； TIME ：该进程实际使用 CPU 运作的时间。 COMMAND：该程序的实际指令。","categories":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"ps命令","slug":"ps命令","permalink":"http://yoursite.com/tags/ps命令/"}]},{"title":"Hello World","slug":"hello-world","date":"2013-07-13T12:46:25.000Z","updated":"2019-01-21T07:55:35.586Z","comments":true,"path":"2013/07/13/hello-world/","link":"","permalink":"http://yoursite.com/2013/07/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"},{"name":"world","slug":"world","permalink":"http://yoursite.com/tags/world/"}]}]}