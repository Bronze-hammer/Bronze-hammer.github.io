{"meta":{"title":"徐子辉的个人站点","subtitle":"Change Myself From Now ON.","description":null,"author":"xuzh","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-01-22T00:54:44.000Z","updated":"2020-01-14T10:12:33.262Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"This is a page about me!"},{"title":"categories","date":"2019-01-22T01:00:35.000Z","updated":"2020-01-14T10:12:33.262Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-22T01:00:21.000Z","updated":"2020-01-14T10:12:33.262Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤","slug":"不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤","date":"2020-03-26T09:38:21.000Z","updated":"2020-03-26T09:58:45.786Z","comments":true,"path":"2020/03/26/不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤/","link":"","permalink":"http://yoursite.com/2020/03/26/不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤/","excerpt":"文章来自 Hollis 数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。 在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。","text":"文章来自 Hollis 数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。 在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。 关于数据库中行数统计，无论是MySQL还是Oracle，都有一个函数可以使用，那就是COUNT。但是，就是这个常用的COUNT函数，却暗藏着很多玄机，尤其是在面试的时候，一不小心就会被虐。不信的话请尝试回答下以下问题： 1、COUNT有几种用法？2、COUNT(字段名)和COUNT()的查询结果有什么不同？3、COUNT(1)和COUNT()之间有什么不同？4、COUNT(1)和COUNT()之间的效率哪个更高？5、为什么《阿里巴巴Java开发手册》建议使用COUNT()6、MySQL的MyISAM引擎对COUNT()做了哪些优化？7、MySQL的InnoDB引擎对COUNT()做了哪些优化？8、上面提到的MySQL对COUNT()做的优化，有一个关键的前提是什么？9、SELECT COUNT() 的时候，加不加where条件有差别吗？10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？ 以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解COUNT函数了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。 认识COUNT关于COUNT函数，在MySQL官网中有详细介绍： 简单翻译一下： 1、COUNT(expr) ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个BIGINT值。 2、如果查询结果没有命中任何记录，则返回0 3、但是，值得注意的是，COUNT(*) 的统计结果中，会包含值为NULL的行数。 即以下表记录 12345678create table #bla(id int,id2 int)insert #bla values(null,null)insert #bla values(1,null)insert #bla values(null,1)insert #bla values(1,null)insert #bla values(null,1)insert #bla values(1,null)insert #bla values(null,null) 使用语句count(*),count(id),count(id2)查询结果如下： 12select count(*),count(id),count(id2)from #bla results 7 3 2 除了COUNT(id)和COUNT(*)以外，还可以使用COUNT(常量)（如COUNT(1)）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 COUNT(列名)或 COUNT(常量)来替代 COUNT(*)呢？ COUNT(列名)、COUNT(常量)和COUNT(*)之间的区别前面我们提到过COUNT(expr)用于做行数统计，统计的是expr不为NULL的行数，那么COUNT(列名)、 COUNT(常量) 和 COUNT()这三种语法中，expr分别是列名、 常量 和 。 那么列名、 常量 和 *这三个条件中，常量 是一个固定值，肯定不为NULL。*可以理解为查询整行，所以肯定也不为NULL，那么就只有列名的查询结果有可能是NULL了。 所以， COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。 除了查询得到结果集有区别之外，COUNT(*)相比COUNT(常量) 和 COUNT(列名)来讲，COUNT(*)是SQL92定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。 SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。 COUNT(*)的优化前面提到了COUNT(*)是SQL92定义的标准统计行数的语法，所以MySQL数据库对他进行过很多优化。那么，具体都做过哪些事情呢？ 这里的介绍要区分不同的执行引擎。MySQL中比较常用的执行引擎就是InnoDB和MyISAM。 MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的COUNT(*)有关，那就是MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。 因为MyISAM的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用COUNT(*)进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。 MyISAM之所以可以把表中的总行数记录下来供COUNT(*)查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。 但是，对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。 但是，InnoDB还是针对COUNT(*)语句做了些优化的。 在InnoDB中，使用COUNT(*)查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。 从MySQL 8.0.13开始，针对InnoDB的 SELECT COUNT(*) FROM tbl_name 语句，确实在扫表的过程中做了一些优化。前提是查询语句中不包含WHERE或GROUP BY等条件。 我们知道，COUNT(*)的目的只是为了统计总行数，所以，他根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。 我们知道，InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。 所以，相比之下，非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。 至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。 COUNT(*)和COUNT(1)介绍完了COUNT()，接下来看看COUNT(1)，对于，这二者到底有没有区别，网上的说法众说纷纭。有的说COUNT()执行时会转换成COUNT(1)，所以COUNT(1)少了转换步骤，所以更快。还有的说，因为MySQL针对COUNT(*)做了特殊优化，所以COUNT(*)更快。 那么，到底哪种说法是对的呢？看下MySQL官方文档是怎么说的： InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference. 画重点：same way , no performance difference。所以，对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！ 那既然COUNT(*)和COUNT(1)一样，建议用哪个呢？ 建议使用COUNT(*)！因为这个是SQL92定义的标准统计行数的语法，而且本文只是基于MySQL做了分析，关于Oracle中的这个问题，也是众说纷纭的呢。 COUNT(字段)最后，就是我们一直还没提到的COUNT(字段)，他的查询就比较简单粗暴了，就是进行全表扫描，然后判断指定字段的值是不是为NULL，不为NULL则累加。相比COUNT(*)，COUNT(字段)多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比COUNT(*)慢。 总结本文介绍了COUNT函数的用法，主要用于统计表行数。主要用法有COUNT()、COUNT(字段)和COUNT(1)。因为COUNT(\\)是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT(*)查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。 在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样，但是COUNT(字段)需要进行字段的非NULL判断，所以效率会低一些。 因为COUNT(*)是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用COUNT(*)查询表的行数！ 参考资料： https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count 《极客时间——MySQL实战45讲》","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"},{"name":"COUNT","slug":"COUNT","permalink":"http://yoursite.com/tags/COUNT/"}]},{"title":"Oracle索引","slug":"Oracle索引","date":"2020-03-23T02:41:40.000Z","updated":"2020-03-26T09:39:37.090Z","comments":true,"path":"2020/03/23/Oracle索引/","link":"","permalink":"http://yoursite.com/2020/03/23/Oracle索引/","excerpt":"索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。 在没有创建索引之前，如果要按照用户名字段username全表查询一条用户数据，就要必须在全表都搜索一遍；在username上创建索引，Oracle会对全表进行一次搜索，将每条记录的username按照顺序排序，然后构建索引条目（name和rowid），存储到索引段中。在接下来查找username等于某个值时即可直接查找到相应的地方。","text":"索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。 在没有创建索引之前，如果要按照用户名字段username全表查询一条用户数据，就要必须在全表都搜索一遍；在username上创建索引，Oracle会对全表进行一次搜索，将每条记录的username按照顺序排序，然后构建索引条目（name和rowid），存储到索引段中。在接下来查找username等于某个值时即可直接查找到相应的地方。 文章来自 FREE教程 既然我们都知道建立索引有利于查询速率的提升，那是不是所有字段都可以加上索引。这是万万不行的，建立索引不仅仅要浪费空间来存储索引表，当数据量较少时，直接查询数据比经过查询索引表再定位到表数据的速度更快。索引可以提高查询的效率，但是在数据增删改时需要更新索引，因此索引对增删改时会有负面影响。所以要根据实际情况， 考虑好再建立索引。 何时建立索引那何时建立索引，下面大概介绍几点，其余的得在实际应用和开发过程中，酌情考虑： 1、Oracle 数据库会为表的主键和包含唯一约束的列自动创建索引，所以在建立唯一约束时，可以考虑该列是否必要建立。是否经常要作为查询条件。 2、如果某个表的数据量较大（十几二十万以上），某列经常作为where的查询条件，并且检索的出来的行数经常是小于总表的5%，那该列可以考虑建立索引。 3、对于两表连接的字段，应该考虑建立索引。如果经常在某表的一个字段进行Order By 则也经过进行索引。 4、不应该在小表上建立索引。上面也说过，小表之间查询的数据会比建立索引的查询速度更快，但是在某些字段，如性别：只有男、女和未知三种数据时，可以考虑位图索引，可以增加查询效率。 5、经常进行DML操作，即经常进行增删改的操作的表，创建表索引时就要权衡一下，因为建索引会导致进行DML操作时速度变慢。所以可以根据实际情况，选择某些字段建立索引，而不能盲目乱建。 索引的类别适当的使用索引可以提高数据检索速度，那Oracle有哪些类型的索引呢？ 1、b-tree索引：Oracle数据中最常见的索引，就是b-tree索引，create index创建的normal就是b-tree索引，没有特殊的必须应用在哪些数据上。 2、bitmap位图索引：位图索引经常应用于列数据只有几个枚举值的情况，比如上面说到过的性别字段，或者我们经常开发中应用的代码字段。这个时候使用bitmap位图索引，查询效率将会最快。 3、函数索引：比如经常对某个字段做查询的时候经常是带函数操作的，那么此时建一个函数索引就有价值了。例如：trim（列名）或者substr(列名)等等字符串操作函数，这个时候可以建立函数索引来提升这种查询效率。 4、hash索引：hash索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。创建hash索引必须使用hash集群，相当于定义了一个hash集群键，通过这个集群键来告诉oracle来存储表。因此，需要在创建hash集群的时候指定这个值。存储数据时，所有相关集群键的行都存储在一个数据块当中，所以只要定位到hash键，就能快速定位查询到数据的物理位置。 5、reverse反向索引：这个索引不经常使用到，但是在特定的情况下，是使用该索引可以达到意想不到的效果。如：某一列的值为{10000,10001,10021,10121,11000,….}，假如通过b-tree索引，大部分都密集发布在某一个叶子节点上，但是通过反向处理后的值将变成{00001,10001,12001,12101,00011,…}，很明显的发现他们的值变得比较随机，可以比较平均的分部在各个叶子节点上，而不是之前全部集中在某一个叶子节点上，这样子就可大大提高检索的效率。 6、分区索引和分区表的全局索引：这两个索引是应用在分区表上面的，前者的分区索引是对分区表内的单个分区进行数据索引，后者是对分区表的全表进行全局索引。分区表的介绍，可以后期再做单独详解，这里就不累述了。 创建索引语法结构：123456789101112create[unique]|[bitmap] index index_name --UNIQUE表示唯一索引、BITMAP位图索引on table_name(column1,column2...|[express])--express表示函数索引[tablespace tab_name] --tablespace表示索引存储的表空间[pctfree n1] --索引块的空闲空间n1[storage --存储块的空间 ( initial 64K --初始64k next 1M minextents 1 maxextents unlimited )]; Oracle要求创建索引的列不能超过32列 语法解析：1、UNIQUE:指定索引列上的值必须是唯一的。称为唯一索引，BITMAP表示位图索引。 2、index_name：指定索引名。 3、tabl_name：指定要为哪个表创建索引。 4、column_name：指定要对哪个列创建索引。我们也可以对多列创建索引，这种索引称为组合索引。也可以是函数表达式，这种就是函数索引。 修改索引：1、重命名索引：1alter index index_old rename to index_new;--重新命名索引 2、合并索引、重新构造索引：我们索引建好后，经过很长一段时间的使用，索引表中存储的空间会产生一些碎片，导致索引的查询效率会有所下降，这个时候可以合并索引，原理是按照索引规则重新分类存储一下，或者也可以选择删除索引重新构造索引。12alter index index_name coalesce;--合并索引alter index index_name rebuild;--重新构造 删除索引：1drop index index_name; 查看索引：1234567select t.INDEX_NAME,--索引名字 t.index_type,--索引类型 t.TABLESPACE_NAME,--表空间 t.status,--状态 t.UNIQUENESS--是否唯一索引 from all_indexes T where t.INDEX_NAME='index_name'; 案例分析：案例1、学生信息表（stuinfo）创建的时候就对学号（stuid）设置了主键（PK_STUINFO），当我们学生信息表数据量大的情况下，我们明显发现班号（classno）需要一个索引，不仅仅是用来关联班级信息表（class）、而且经常作为查询条件，因此创建脚本如下：123456789101112create index STUDENT.IDX_STUINFO_CLASSNO on STUDENT.STUINFO (CLASSNO) tablespace USERS pctfree 10 initrans 2 maxtrans 255 storage ( initial 64K next 1M minextents 1 maxextents unlimited ); 案例2、对于学生信息我们经常用性别作为统计条件进行对学生信息进行统计，因此我们可以在性别（sex）建立一个位图索引进行查询优化。代码如下：123456789101112create bitmap index STUDENT.IDX_STUINFO_SEX on STUDENT.STUINFO (SEX) tablespace USERS pctfree 10 initrans 2 maxtrans 255 storage ( initial 64K next 1M minextents 1 maxextents unlimited ); 查询一下三种索引的状态：12345678select t.INDEX_NAME, t.index_type, t.TABLESPACE_NAME, t.status, t.UNIQUENESS from all_indexes T where t.TABLE_NAME='STUINFO' AND T.OWNER='STUDENT' 结果如下：","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"},{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"}]},{"title":"理解线程安全","slug":"理解线程安全","date":"2019-05-28T09:04:43.000Z","updated":"2020-01-14T10:12:33.262Z","comments":true,"path":"2019/05/28/理解线程安全/","link":"","permalink":"http://yoursite.com/2019/05/28/理解线程安全/","excerpt":"转自 编程新说李新杰 不是线程的安全面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。 论语中有句话叫“学而优则仕”，相信很多人都觉得是“学习好了可以做官”。然而，这样理解却是错的。切记望文生义。 同理，“线程安全”也不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。 目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。 在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。 假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。 比如把你住的小区看作一个进程，小区里的道路/绿化等就属于公共区域。你拿1万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。 因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。 所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。 即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程“破坏”。 那我们该怎么办呢？解决问题的过程其实就是一个取舍的过程，不同的解决方案有不同的侧重点。","text":"转自 编程新说李新杰 不是线程的安全面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。 论语中有句话叫“学而优则仕”，相信很多人都觉得是“学习好了可以做官”。然而，这样理解却是错的。切记望文生义。 同理，“线程安全”也不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。 目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。 在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。 假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。 比如把你住的小区看作一个进程，小区里的道路/绿化等就属于公共区域。你拿1万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。 因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。 所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。 即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程“破坏”。 那我们该怎么办呢？解决问题的过程其实就是一个取舍的过程，不同的解决方案有不同的侧重点。 私有的东西就不该让别人知道现实中很多人都会把1万块钱藏着掖着，不让无关的人知道，所以根本不可能扔到大马路上。因为这钱是你的私有物品。 在程序中也是这样的，所以操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问。这也是由操作系统保障的。 如果一些数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。较为常见的就是局部变量。 123456789double avgScore(double[] scores) &#123; double sum = 0; for (double score : scores) &#123; sum += score; &#125; int count = scores.length; double avg = sum / count; return avg;&#125; 这里的变量sum，count，avg都是局部变量，它们都会被分配在线程栈内存中。 假如现在A线程来执行这个方法，这些变量会在A的栈内存分配。与此同时，B线程也来执行这个方法，这些变量也会在B的栈内存中分配。 也就是说这些局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。 就像每个人的家只属于自己，其他人不能进来。所以你把1万块钱放到家里，其他人是不会知道的。且一般还会放到某个房间里，而不是仍在客厅的桌子上。 所以把自己的东西放到自己的私人地盘，是安全的，因为其他人无法知道。而且越隐私的地方越好。 大家不要抢，人人有份相信聪明的你已经发现，上面的解决方案是基于“位置”的。因为你放东西的“位置”只有你自己知道（或能到达），所以东西是安全的，因此这份安全是由“位置”来保障的。 在程序里就对应于方法的局部变量。局部变量之所以是安全的，就是因为定义它的“位置”是在方法里。这样一来安全是达到了，但是它的使用范围也就被限制在这个方法里了，其它方法想用也不用了啦。 现实中往往会有一个变量需要多个方法都能够使用的情况，此时定义这个变量的“位置”就不能在方法里面了，而应该在方法外面。即从（方法的）局部变量变为（类的）成员变量，其实就是“位置”发生了变化。 那么按照主流编程语言的规定，类的成员变量不能再分配在线程的栈内存中，而应该分配在公共的堆内存中。其实也就是变量在内存中的“位置”发生了变化，由一个私有区域来到了公共区域。因此潜在的安全风险也随之而来。 那怎么保证在公共区域的东西安全呢？答案就是，大家不要抢，人人有份。设想你在街头免费发放矿泉水，来了1万人，你却只有1千瓶水，结果可想而知，一拥而上，场面失守。但如果你有10万瓶水，大家一看，水多着呢，不用着急，一个个排着队来，因为肯定会领到。 东西多了，自然就不值钱了，从另一个角度来说，也就安全了。大街上的共享单车，现在都很安全，因为太多了，到处都是，都长得一样，所以连搞破坏的人都放弃了。因此要让一个东西安全，就疯狂的copy它吧。 回到程序里，要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。相信你已经猜到了，我要表达的就是ThreadLocal类了。 123456789101112131415161718192021222324252627282930313233343536373839class StudentAssistant &#123; ThreadLocal&lt;String&gt; realName = new ThreadLocal&lt;&gt;(); ThreadLocal&lt;Double&gt; totalScore = new ThreadLocal&lt;&gt;(); String determineDegree() &#123; double score = totalScore.get(); if (score &gt;= 90) &#123; return \"A\"; &#125; if (score &gt;= 80) &#123; return \"B\"; &#125; if (score &gt;= 70) &#123; return \"C\"; &#125; if (score &gt;= 60) &#123; return \"D\"; &#125; return \"E\"; &#125; double determineOptionalcourseScore() &#123; double score = totalScore.get(); if (score &gt;= 90) &#123; return 10; &#125; if (score &gt;= 80) &#123; return 20; &#125; if (score &gt;= 70) &#123; return 30; &#125; if (score &gt;= 60) &#123; return 40; &#125; return 60; &#125;&#125; 这个学生助手类有两个成员变量，realName和totalScore，都是ThreadLocal类型的。每个线程在运行时都会拷贝一份存储到自己的本地。 A线程运行的是“张三”和“90”，那么这两个数据“张三”和“90”是存储到A线程对象（Thread类的实例对象）的成员变量里去了。假设此时B线程也在运行，是“李四”和“85”，那么“李四”和“85”这两个数据是存储到了B线程对象（Thread类的实例对象）的成员变量里去了。 线程类（Thread）有一个成员变量，类似于Map类型的，专门用于存储ThreadLocal类型的数据。从逻辑从属关系来讲，这些ThreadLocal数据是属于Thread类的成员变量级别的。从所在“位置”的角度来讲，这些ThreadLocal数据是分配在公共区域的堆内存中的。 说的直白一些，就是把堆内存中的一个数据复制N份，每个线程认领1份，同时规定好，每个线程只能玩自己的那份，不准影响别人的。 需要说明的是这N份数据都还是存储在公共区域堆内存里的，经常听到的“线程本地”，是从逻辑从属关系上来讲的，这些数据和线程一一对应，仿佛成了线程自己“领地”的东西了。其实从数据所在“位置”的角度来讲，它们都位于公共的堆内存中，只不过被线程认领了而已。这一点我要特地强调一下。 其实就像大街上的共享单车。原来只有1辆，大家抢着骑，老出问题。现在从这1辆复制出N辆，每人1辆，各骑各的，问题得解。共享单车就是数据，你就是线程。骑行期间，这辆单车从逻辑上来讲是属于你的，从所在位置上来讲还是在大街上这个公共区域的，因为你发现每个小区大门口都贴着“共享单车，禁止入门”。哈哈哈哈。 共享单车是不是和ThreadLocal很像呀。再重申一遍，ThreadLocal就是，把一个数据复制N份，每个线程认领一份，各玩各的，互不影响。 只能看，不能摸放在公共区域的东西，只是存在潜在的安全风险，并不是说一定就不安全。有些东西虽然也在公共区域放着，但也是十分安全的。比如你在大街上放一个上百吨的石头雕像，就非常安全，因为大家都弄不动它。 再比如你去旅游时，经常发现一些珍贵的东西，会被用铁栅栏围起来，上面挂一个牌子，写着“只能看，不能摸”。当然可以国际化一点，“only look，don’t touch”。这也是很安全的，因为光看几眼是不可能看坏的。 回到程序里，这种情况就属于，只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了。 1234class StudentAssistant &#123; final double passScore = 60;&#125; 比如把及格分数设定为60分，在前面加上一个final，这样所有线程都动不了它了。这就很安全了。 小节一下：以上三种解决方案，其实都是在“耍花招”。 第一种，找个只有自己知道的地方藏起来，当然安全了。 第二种，每人复制1份，各玩各的，互不影响，当然也安全了。 第三种，更狠了，直接规定，只能读取，禁止修改，当然也安全了。 是不是都在“避重就轻”呀。如果这三种方法都解决不了，该怎么办呢？Don’t worry，just continue reading。 没有规则，那就先入为主前面给出的三种方案，有点“理想化”了。现实中的情况其实是非常混乱嘈杂的，没有规则的。 比如在中午高峰期你去饭店吃饭，进门后发现只剩一个空桌子了，你心想先去点餐吧，回来就坐这里吧。当你点完餐回来后，发现已经被别人捷足先登了。 因为桌子是属于公共区域的物品，任何人都可以坐，那就只能谁先抢到谁坐。虽然你在人群中曾多看了它一眼，但它并不会记住你容颜。 解决方法就不用我说了吧，让一个人在那儿看着座位，其它人去点餐。这样当别人再来的时候，你就可以理直气壮的说，“不好意思，这个座位，我，已经占了”。 我再次相信聪明的你已经猜到了我要说的东西了，没错，就是（互斥）锁。 回到程序里，如果公共区域（堆内存）的数据，要被多个线程操作时，为了确保数据的安全（或一致）性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说吧。 假设一个线程来到数据跟前一看，发现锁是空闲的，没有人持有。于是它就拿到了这把锁，然后开始操作数据，干了一会活，累了，就去休息了。 这时，又来了一个线程，发现锁被别人持有着，按照规定，它不能操作数据，因为它无法得到这把锁。当然，它可以选择等待，或放弃，转而去干别的。 第一个线程之所以敢大胆的去睡觉，就是因为它手里拿着锁呢，其它线程是不可能操作数据的。当它回来后继续把数据操作完，就可以把锁给释放了。锁再次回到空闲状态，其它线程就可以来抢这把锁了。还是谁先抢到锁谁操作数据。 1234567891011121314151617class ClassAssistant &#123; double totalScore = 60; final Lock lock = new Lock(); void addScore(double score) &#123; lock.obtain(); totalScore += score; lock.release(); &#125; void subScore(double score) &#123; lock.obtain(); totalScore -= score; lock.release(); &#125;&#125; 假定一个班级的初始分数是60分，这个班级抽出10名学生来同时参加10个不同的答题节目，每个学生答对一次为班级加上5分，答错一次减去5分。因为10个学生一起进行，所以这一定是一个并发情形。 因此加分和减分这两个方法被并发的调用，它们共同操作总分数。为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。 相信世界充满爱，即使被伤害再回到一开始的例子，假如你往地上仍1万块钱，是不是一定会丢呢？这要看情况了，如果是在人来人往的都市，可以说肯定会丢的。如果你跑到无人区扔地上，可以说肯定不会丢。 可以看到，都是把东西无保护的放到公共区域里，结果却相差很大。这说明安全问题还和公共区域的环境状况有关系。 比如我把数据放到公共区域的堆内存中，但是始终都只会有1个线程，也就是单线程模型，那这数据肯定是安全的。 再者说，2个线程操作同一个数据和200个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，线程越少数据不安全的概率越小。取个极限情况，那就是只有1个线程，那不安全概率就是0，也就是安全的。 可能你又猜到了我想表达的内容了，没错，就是CAS。可能大家觉得既然锁可以解决问题，那就用锁得了，为啥又冒出了个CAS呢？ 那是因为锁的获取和释放是要花费一定代价的，如果在线程数目特别少的时候，可能根本就不会有别的线程来操作数据，此时你还要获取锁和释放锁，可以说是一种浪费。 针对这种“地广人稀”的情况，专门提出了一种方法，叫CAS（Compare And Swap）。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用CAS。 假如一个线程操作数据，干了一半活，累了，想要去休息。（貌似今天的线程体质都不太好）。于是它记录下当前数据的状态（就是数据的值），回家睡觉了。 醒来后打算继续接着干活，但是又担心数据可能被修改了，于是就把睡觉前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明自己在睡觉期间，数据没有被人动过（当然也有可能是先被改成了其它，然后又改回来了，这就是ABA问题了），那就接着继续干。如果不一样，说明数据已经被修改了，那之前做的那些操作其实都白瞎了，就干脆放弃，从头再重新开始处理一遍。 所以CAS这种方式适用于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。如果并发量很高的话，你的数据一定会被修改，每次都要放弃，然后从头再来，这样反而花费的代价更大了，还不如直接加锁呢。 这里再解释下ABA问题，假如你睡觉前数据是5，醒来后数据还是5，并不能肯定数据没有被修改过。可能数据先被修改成8然后又改回到5，只是你不知道罢了。对于这个问题，其实也很好解决，再加一个版本号字段就行了，并规定只要修改数据，必须使版本号加1。 这样你睡觉前数据是5版本号是0，醒来后数据是5版本号是0，表明数据没有被修改。如果数据是5版本号是2，表明数据被改动了2次，先改为其它，然后又改回到5。 我再次相信聪明的你已经发现了，这里的CAS其实就是乐观锁，上一种方案里的获取锁和释放锁其实就是悲观锁。乐观锁持乐观态度，就是假设我的数据不会被意外修改，如果修改了，就放弃，从头再来。悲观锁持悲观态度，就是假设我的数据一定会被意外修改，那干脆直接加锁得了。 作者观点：前两种属于隔离法，一个是位置隔离，一个是数据隔离。 然后两种是标记法，一个是只读标记，一个是加锁标记。 最后一种是大胆法，先来怼一把试试，若不行从头再来。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"线程安全","slug":"线程安全","permalink":"http://yoursite.com/tags/线程安全/"}]},{"title":"单例模式的7种写法","slug":"单例模式的7种写法","date":"2019-04-28T08:28:57.000Z","updated":"2020-01-14T10:12:33.262Z","comments":true,"path":"2019/04/28/单例模式的7种写法/","link":"","permalink":"http://yoursite.com/2019/04/28/单例模式的7种写法/","excerpt":"文章转自公众号无敌码农 | 谁要是再问你单例模式，那就抛给他这7种写法吧！ 单例设计模式是23种设计模式中，最基础也是最常用的设计模式之一，也是面试中关于设计模式知识点考察比较高频的问题之一。说起单例模式的写法，大多数情况下出现在我们脑海中的可能就是“饿汉式”，“懒汉式”这两种写法，但是今天小码哥今天要介绍的是单例模式的7种写法，以后面试官要是再问你单例模式，那就抛给他这七种写法吧！","text":"文章转自公众号无敌码农 | 谁要是再问你单例模式，那就抛给他这7种写法吧！ 单例设计模式是23种设计模式中，最基础也是最常用的设计模式之一，也是面试中关于设计模式知识点考察比较高频的问题之一。说起单例模式的写法，大多数情况下出现在我们脑海中的可能就是“饿汉式”，“懒汉式”这两种写法，但是今天小码哥今天要介绍的是单例模式的7种写法，以后面试官要是再问你单例模式，那就抛给他这七种写法吧！ 接下来，我们就言归正传，来一一介绍这七种单例模式的写法吧！ 饿汉式饿汉式是单例模式设计中比较经典的实现方式。实现代码如下： 1234567891011121314151617//final不允许被继承public final class SingleTonEhangshi &#123; //实例变量 private byte[] data = new byte[1024]; //在定义实例对象时直接初始化 private static SingleTonEhangshi instance = new SingleTonEhangshi(); //私有化构造函数，不允许外部NEW private SingleTonEhangshi() &#123; &#125; public static SingleTonEhangshi getInstance() &#123; return instance; &#125;&#125; 饿汉式的实现关键在于instance作为类变量直接得到了初始化，如果我们主动使用SingleToEhangshi类，那么instance实例将会直接完成创建，包括其中的实例变量也都会得到初始化。 instance作为类变量，在类初始化的过程中会被收集进&lt;clinit>()方法中，而该方法是可以100%地保证同步，也就是说instance在多线程的情况下不可能被初始化两次。但是由于instance被ClassLoader加载后很长一段时间才被使用的话，那就会意味着instance实例所开辟的堆内存会驻留很长的时间。 总体说来，如果一个类中的成员变量比较少，且占用的内存资源也不多，用饿汉式的方式实现单例模式也未尝不可，只是其无法进行懒加载。 懒汉式所谓懒汉式就是在使用类实例的时候再去创建，也就是说用到的时候我再创建，这样就可以避免类在初始化的时候提前创建过早地占用内存空间。实现代码如下： 1234567891011121314151617181920//final不允许被继承public final class SingleTonLhangshi &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static SingleTonLhangshi instance = null; //私有化构造函数，不允许外部NEW private SingleTonLhangshi() &#123; &#125; public static SingleTonLhangshi getInstance() &#123; if (null == instance) &#123; instance = new SingleTonLhangshi(); &#125; return instance; &#125;&#125; 类变量instance=null,因此当类被初始化的时候instance并不会立刻被实例化，而是在getInstance()方法被调用时判断instance实例是否被实例化，如果没有实例化在调用私有构造方法进行实例化操作。 懒汉式写法在多线程环境下，会存在同一时间多个线程同时看到null==instance的情况，从而导致instance会被实例化多次，从而无法保证单例的唯一性。 懒汉式＋同步方法懒汉式的单例实现方式可以保证实例的懒加载，但是却无法保证实例的唯一性。在多线程环境下由于instance为共享数据，当多个线程访问使用时，需要保证数据的同步性，所以如果需要保证懒汉式实例的唯一性，我们可以通过同步的方式来实现。代码如下：123456789101112131415161718192021//final不允许被继承public final class SingleTonLhangshiSync &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static SingleTonLhangshiSync instance = null; //私有化构造函数，不允许外部NEW private SingleTonLhangshiSync() &#123; &#125; //向getInstance方法加入同步控制，每次只能有一个线程能够进入 public static synchronized SingleTonLhangshiSync getInstance() &#123; if (null == instance) &#123; instance = new SingleTonLhangshiSync(); &#125; return instance; &#125;&#125; 采用懒汉式＋数据同步的方法既满足了懒加载又能够100%保证instance实例的唯一性。但是，synchronized关键字的排它性会导致getInstance()方法同一时刻只能被一个线程访问，性能会比较低下。 Double-CheckDouble-Check是一种比较聪明的设计方式，它提供了一种高效的数据同步策略，那就是首次初始化的时候加锁，之后则允许多个线程同时进行getInstance()方法的调用来获得类的实例。代码如下：12345678910111213141516171819202122232425262728293031//final不允许被继承public final class SingletonDoubleCheck &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static SingletonDoubleCheck instance = null; Connection con; Socket socket; //私有化构造函数，不允许外部NEW private SingletonDoubleCheck(Connection con, Socket socket) &#123; this.con = con;//初始化 this.socket = socket;//初始化 &#125; public static SingletonDoubleCheck getInstance() &#123; //当instance为null时，进入同步代码块，同时该判断避免了每次都需要进入同步代码块，可以提高效率 if (null == instance) &#123; //只有一个线程能够获得SingletonDoubleCheck.class关联的monitor synchronized (SingletonDoubleCheck.class) &#123; //判断如果instance为null则创建 if (null == instance) &#123; instance = new SingletonDoubleCheck(); &#125; &#125; &#125; return instance; &#125;&#125; 当两个线程发现null==instance成立时，只有一个线程有资格进入同步代码块，完成对instance的初始化，随后的线程发现null==instance不成立则无须进行任何操作，以后对getInstance的访问就不会再需要进行数据同步了。 此种方式看起来是既满足了懒加载，又保证了instance实例的唯一性，并且还提供了比较高效的数据同步策略，可以允许多个线程同时对getInstance进行访问。但是这种方式在多线程的情况下，可能会引起空指针异常，这是因为如果在如上代码的构造方法中还存在初始化其他资源的情况的话，由于JVM运行时存在指令重排的情况，这些资源在实例化时顺序并无前后关系的约束，那么在这种情况下，就极有可能是instance最先被实例化，而con和socket并未完成实例化，而未完成实例化的实例在调用其方法时将会抛出空指针异常。 Volatile+Double-Check为了解决Double-Check指令重排导致的空指针问题，可以用volatile关键字防止这种重排序的发生。因此代码只需要稍作修改就能满足多线程下的单例、懒加载以及实例的高效性了。代码如下：1234567891011121314151617181920212223242526272829303132//final不允许被继承public final class SingletonDoubleCheck &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static volatile SingletonDoubleCheck instance = null; Connection con; Socket socket; //私有化构造函数，不允许外部NEW private SingletonDoubleCheck(Connection con, Socket socket) &#123; this.con = con;//初始化 this.socket = socket;//初始化 &#125; public static SingletonDoubleCheck getInstance() &#123; //当instance为null时，进入同步代码块，同时该判断避免了每次都需要进入同步代码块，可以提高效率 if (null == instance) &#123; //只有一个线程能够获得SingletonDoubleCheck.class关联的monitor synchronized (SingletonDoubleCheck.class) &#123; //判断如果instance为null则创建 if (null == instance) &#123; instance = new SingletonDoubleCheck(); &#125; &#125; &#125; return instance; &#125;&#125; Holder方式Holder方式完全借助了类加载的特点。代码如下：12345678910111213141516171819//不允许被继承public final class SingletonHolder &#123; //实例变量 private byte[] data = new byte[1024]; private SingletonHolder() &#123; &#125; //在静态内部类中持有单例类的实例，并且可直接被初始化 private static class Holder &#123; private static SingletonHolder instance = new SingletonHolder(); &#125; //调用getInstance方法，事实上是获得Holder的instance静态属性 public static SingletonHolder getInstance() &#123; return Holder.instance; &#125;&#125; 在单例类中并没有instance的静态成员，而是将其放到了静态内部类Holder之中，因此单例类在初始化的过程中并不会创建SingletonHolder的实例，内部类Holder中定义了SingletonHolder的静态变量，并且直接进行了实例化，只有当Holder被主动引用的时候才会创建SingletonHolder的实例。 SingletonHolder实例的创建过程在Java程序编译时期收集至&lt;clinit>()方法中，该方法又是同步方法，可以保证内存的可见性、JVM指令的顺序性和原子性。Holder方式的单例模式设计是最好的设计之一，也是目前使用比较广的设计。 枚举方式枚举方式在很多开源框架中也应用得比较广泛，枚举类型不允许被继承，同样是线程安全的，并且只能被实例化一次，但是枚举类型不能够实现懒加载。用枚举类型，实现单例模式的代码如下：1234567891011121314151617181920212223242526public class SingletonEnum &#123; //实例变量 private byte[] data = new byte[1024]; private SingletonEnum() &#123; &#125; //使用枚举充当Holder private enum EnumHolder &#123; INSTANCE; private SingletonEnum instance; EnumHolder() &#123; this.instance = new SingletonEnum(); &#125; private SingletonEnum getInstance() &#123; return instance; &#125; &#125; public static SingletonEnum getInstance() &#123; return EnumHolder.INSTANCE.getInstance(); &#125;&#125; 以上就是要给大家介绍的单例模式的7种写法了，虽然单例模式非常简单，但是在多线程的情况下，我们之前所设计的单例程序未必能够满足单实例、懒加载以及高性能的特点。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"单例模式","slug":"单例模式","permalink":"http://yoursite.com/tags/单例模式/"}]},{"title":"Linux定时任务","slug":"Linux定时任务","date":"2019-04-28T08:12:54.000Z","updated":"2020-01-14T10:12:33.247Z","comments":true,"path":"2019/04/28/Linux定时任务/","link":"","permalink":"http://yoursite.com/2019/04/28/Linux定时任务/","excerpt":"文章转自 菜鸟教程 inux内置的cron进程能帮我们实现这些需求，cron搭配shell脚本，非常复杂的指令也没有问题。 cron介绍我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。 /var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名 /etc/crontab 这个文件负责调度各种管理和维护任务。 /etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。 我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。","text":"文章转自 菜鸟教程 inux内置的cron进程能帮我们实现这些需求，cron搭配shell脚本，非常复杂的指令也没有问题。 cron介绍我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。 /var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名 /etc/crontab 这个文件负责调度各种管理和维护任务。 /etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。 我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。 crontab的使用我们常用的命令如下： 1234crontab [-u username] //省略用户表表示操作当前用户的crontab -e (编辑工作表) -l (列出工作表里的命令) -r (删除工作作) 我们用 crontab -e 进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。 crontab的命令构成为 时间+动作，其时间有 分、时、日、月、周 五种，操作符有 * 取值范围内的所有数字 / 每过多少个数字 - 从X到Z ，散列数字 实例实例1：每1分钟执行一次myCommand1* * * * * myCommand 实例2：每小时的第3和第15分钟执行13,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行13,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行13,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行13,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb130 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb145 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb110 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb10,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb10 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb1* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb1* 23-7/1 * * * /etc/init.d/smb restar","categories":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"定时任务","slug":"定时任务","permalink":"http://yoursite.com/tags/定时任务/"}]},{"title":"Oracle的一些故障处理","slug":"Oracle的一些故障处理","date":"2019-04-08T05:17:55.000Z","updated":"2020-01-14T10:12:33.247Z","comments":true,"path":"2019/04/08/Oracle的一些故障处理/","link":"","permalink":"http://yoursite.com/2019/04/08/Oracle的一些故障处理/","excerpt":"这里汇总了一些在使用Oracle过程中遇到的问题及解决办法，一方面做为笔记帮助自己以后更快速处理问题，一方面分享处理供大家互相学习。","text":"这里汇总了一些在使用Oracle过程中遇到的问题及解决办法，一方面做为笔记帮助自己以后更快速处理问题，一方面分享处理供大家互相学习。 ⚪SP2-0667: Message file sp1.msb not found 出错原因：crontab里面的脚本，通常读取的是默认的环境变量，PATH里面不包含oracle数据库的路径。 解决办法：1vim ~/.bashrc 把一下内容填写其中 12export ORACLE_HOME=/u01/app/oracle/product/11.2.0/dbhome_1export PATH=$ORACLE_HOME/bin:$PATH 注意，ORACLE_HOME的路径要是你计算机中oracle真实的安装地址 环境变量设置完成，执行 source ~/.bashrc 使其生效。 ⚪ORA-12162: TNS:net service name is incorrectly specified 一般出现这种错误，基本都是环境变量配置有问题，要么是没有配置正确的ORACLE_SID、ORACLE_HOME，要么是监听配置环境变量和.bash_profile环境变量配置不一致。 这里检查发现，是操作系统环境变量没有配置ORACLE_SID 因此，我们配置一下 ~/.bashrc ，在其中添加ORACLE_SID 1export ORACLE_SID=erp 注意：ORACLE_SID的值要根据自己安装oracle时设置的为准 ⚪ORA-04021: timeout occurred while waiting to lock object情景描述:Oracle中本来有个用户NC63PM_PEIXUN1，我把这个用户名更改为了NC63PM_PEIXUN2（更改方法请参考【Oracle更改用户名和密码】），之后我想按照旧的用户名再创建一个用户，但是创建的用户的SQL语句执行了十五分钟还没执行完，并报如下的错误： 解决办法查看是否被锁表了 123&gt; SELECT object_name,machine,s.sid,s.serial#&gt; FROM v$locked_object l,dba_objects o ,v$session s&gt; WHERE l.object_id=o.object_id AND l.session_id=s.sid; 发现没有被锁表 使用 DBA_DDL_LOCKS视图获得DDL锁定信息 1&gt; SELECT * FROM dba_ddl_locks; 发现有两条关于 NC63PM_PEIXUN1 用户的锁定信息 通过 session_id 找到对应的锁表信息 1&gt; SELECT sid,serial#,status FROM v$session a WHERE a.sid in (829,392); 注：因我是kill掉这两条信息后才截的图，所以 STATUS 才为 KILLED 的。 kill这两条锁表 12&gt; ALTER SYSTEM KILL SESSION &apos;392, 5049&apos;;&gt; ALTER SYSTEM KILL SESSION &apos;829, 25287&apos;; 再次执行创建用户的脚本就能顺利执行。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}]},{"title":"Java基础知识小结","slug":"Java基础知识小结","date":"2019-03-26T05:44:17.000Z","updated":"2020-01-14T10:12:33.231Z","comments":true,"path":"2019/03/26/Java基础知识小结/","link":"","permalink":"http://yoursite.com/2019/03/26/Java基础知识小结/","excerpt":"写这篇文章是为了记录一下学习中被忽略的知识点，这些知识点虽然知道听说过，但对它们的概念和作用都很模糊，如果别人问起为什么，自己还真解释不上来，因此做个记录，方便以后回顾以及大家一起学习。","text":"写这篇文章是为了记录一下学习中被忽略的知识点，这些知识点虽然知道听说过，但对它们的概念和作用都很模糊，如果别人问起为什么，自己还真解释不上来，因此做个记录，方便以后回顾以及大家一起学习。 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会默认生成一个不带参数且没有任何执行动作的构造方法。 在Java中定义一个不做任何事且没有参数的构造方法的作用Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则系统会自动调用父类中没有参数的构造方法。当此时父类中只定义了有参数的构造方法而没有定义无参数的构造方法，然后在子类的构造方法中又没有使用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到无参数的构造方法可供执行。所以我们要在父类里加上一个不做任何事且没有参数的构造方法。 重载和重写的区别重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。 try-catch-finally try块：用于捕获异常。其后可跟零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch块： 用于处理try捕获的异常。 finally块：无论是否捕获或者处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 注意，一下几种情况finally块不会被执行： 1.在finally语句块中发生了异常； 2.在前面的代码中用了System.exit()退出； 3.程序所有的线程死亡； 4.关闭CPU。 final/finally/finalize的区别finalJava中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量） 当用final修饰一个类时，表明这个类不能被继承 当final修饰一个类中的某个方法，这个类的子类不能重写覆盖这个被修饰的类，也就是说子类是不能够存在和父类一模一样的方法。 final修饰变量，该变量表示常量，只能被赋值一次，赋值后值不能被修改。 finally在异常处理时提供finally块来执行清楚操作。论是否捕获或者处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 finalize是方法名。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除之前做必要的清理工作。这个方法是在垃圾收集器在确定了，被清理对象没有被引用的情况下调用的。 finalize是在Object类中定义的，因此，所有的类都继承了它。子类可以覆盖finalize()方法，来整理系统资源或者执行其他清理工作。 HashMapHashMap的特点 HashMap是基于哈希表的Map接口实现的。 HashMap底层采用的是Entry数组和链表实现的。 HashMap是采用key-value形式存储，其中key是可以允许为null，但是只能有一个，并且key不允许重复（如果重复则新值会覆盖旧值）。 HashMap是线程不安全的。 HashMap存入的顺序和遍历的顺序可能不一致（无序）。 HashMap保存数据的时候通过计算key的hash值来决定存储的位置。 HashMap的工作原理是什么？HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。 HashMap源代码要看HashMap的源代码，我们还是从HashMap的构造方法开始一步一步的讲解。 小总结：可以看出HashMap构造的时候会初始化16个容量，并且负载因子是0.75。负载因子是什么呢？我们后面讲。 小总结：这个构造方法没有什么可说的，只是多了些验证。在这里呢？构造方法就算初始化完毕了。 我们知道HashMap最常用的方法也就是put方法了，那么下面我们就着重去探究一下put方法的实现原理，也就是对HashMap的一个透彻理解。 这段代码好好的研读，请仔细往下看： 第一步： 直接判断 table==EMPTY_TABLE ，那么这个table是什么呢？看下图： 那么这个Entry又是说什么东东呢？ 这个Entry是Map的一个静态内部类，里面最重要的属性有key、value和next三个属性值，在这里，我想大家已经猜到了，这个key和value是不是我们put的时候的key和value呢？答案是的，这个next又是干嘛用的呢？实际上这个Entry的的数据结构是一个单链表，这个next的属性的值还是这个Entry，表示的是当前的节点的下一个节点是哪个Entry。 好啦，源代码看到这里，我们知道，在put方法中，直接判断table是否为null，那么很显然到目前为止我们的table肯定是为null的，那么继续看如果table为null则要执行的代码。看下图： 哇塞，可以很直观的看到，我们实际上是初始化了一个Entry数组，而我们HashMap中的数据都是保存在了Entry[]里面了。 小总结：HashMap其实就是一个线性的Entry数组，而在Entry这个对象中保存了key和value，至于Entry对象中的next的具体作用是干嘛的，稍等做介绍哦。 第二步： 判断key是否为null。从这里可以看出，当判断key如果为null的话，并没有抛出什么异常错误，很显然HashMap是支持key为null的。那么就来看看key如果为null，会怎么处理呢？ 小总结：首先去循环遍历这个Entry数组，判断是否有key为null的情况，如果有则新值覆盖掉旧值。如果没有key为null的情况，则hash值为0，数据存储在这个Entry数组的第0个位置，也就是table[0]，具体方法可以查看addEntry方法，在这里呢，我就不再演示了。 第三步： 通过hash方法对key进行计算hash散列值，并且根据这个散列值查找这个要保存的值应该存储到table这个数组中的哪个索引位置。 第四步： 循环变量这个Entry数组，并且判断是否有重复的元素添加进去。 小总结：当去变量这个Entry数组的时候，去判断两个Entry对象的key的hash是否相同则仅仅表示它们的存储位置是相同的，然后继续判断两个Entry的key是否相等或者equals是否相等，如果条件都满足，则表示要添加的元素，key已经重复，则直接将新值覆盖掉旧值，并且return返回，一旦条件不满足，则直接将添加的元素添加到Entry对象中。 好啦，这个就是整个HashMap的底层原理。现在有的朋友可能会有产生这样的问题：如果计算的key的hash值相等，但是equals方法不相等，那么计算出来的要存储的位置不就冲突了吗？那么如果保存呢？ 解决：实际上这种担忧是有必要的，因为我们完全有可能就是说计算的key的hash值和另一个key的hash值是相等的，那么这个时候呢，如果key的equals方法又不相等，那么这个时候我要保存的value值应该存储到table中的哪个索引上呢？实际上，这种情况叫做hash冲突，学习过数据结构的朋友应该都知道，解决hash冲突的方法有很多，但是在Java中，解决冲突的办法是采用的是链表来解决的。还记得这个Entry的next属性吗？对了，这个next属性就是用来记录这个链表上的下一个Entry。 HashMap的内容摘自http://baijiahao.baidu.com/s?id=1601416041995350500&amp;wfr=spider&amp;for=pc volatile关键字的基本作用和原理volatile关键字可以实现线程间的可见性，之所以可以实现这一点，原因在于JVM会保证被volatile修饰的变量，在线程栈中被线程使用时都会主动从共享内存(堆内存/主内存)中以实时的方式同步一次；另一方面，如果线程在工作内存中修改了volatile修饰的变量，也会被JVM要求立马刷新到共享内存中去。因此，即便某个线程修改了该变量，其他线程也可以立马感知到变化从而实现可见性. 未完待续…","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Oracle存储过程的实现","slug":"Oracle存储过程的实现","date":"2018-03-03T07:22:46.000Z","updated":"2020-01-14T10:12:33.247Z","comments":true,"path":"2018/03/03/Oracle存储过程的实现/","link":"","permalink":"http://yoursite.com/2018/03/03/Oracle存储过程的实现/","excerpt":"Oracle存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（是否给参数要看该存储过程定义的过程中是否设置了参数）来执行它。","text":"Oracle存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（是否给参数要看该存储过程定义的过程中是否设置了参数）来执行它。 准备工作创建一张测试表 students 12345678910create table STUDENTS( id VARCHAR2(50) default sys_guid() not null, name VARCHAR2(20), age NUMBER(4,1), school VARCHAR2(100), grade VARCHAR2(50), address VARCHAR2(500), remarks VARCHAR2(500), ts CHAR(19) default to_char(sysdate,'yyyy-mm-dd hh24:mi:ss')) 插入一条测试数据。当然，也可以插入自己想插入的内容。 12insert into STUDENTS (id, name, age, school, grade, address, remarks, ts)values ('8A17DE17428E45D6E0530100007FABEB', 'xiaoming', 20, 'Changchun University of Architecture', 'Junior', 'Changchun, Jilin', null, '2019-06-12 11:07:57'); 第一个简单的存储过程123456CREATE OR REPLACE PROCEDURE stu_schoolAS school_name VARCHAR2(100);BEGIN SELECT school INTO school_name FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB'; dbms_output.put_line(school_name);END; 执行存储过程，可以在PLSQL对象中看到我们刚才新创建的存储过程，并且没有报错，代表编译成功。 执行存储过程 1CALL stu_school(); 调用时，”()”是必不可少的，无论是有参数还是无参数 在SQL窗口输出页签中可以看到正确的输出内容 四种存储过程存储过程有一下四种情况 无参数存储过程 仅有输入参数存储过程 仅有输出参数存储过程 既有输入又有输出存储过程 下面将对这四种存储过程分别举例说明 无参数存储过程无参数存储过程就如上面写的那个简单的存储过程，也可以这样写： 123456CREATE OR REPLACE PROCEDURE stu_schoolAS school_name students.school%TYPE;BEGIN SELECT school INTO school_name FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB'; dbms_output.put_line(school_name);END; 仅有输入参数存储过程123456CREATE OR REPLACE PROCEDURE stu_address(stu_id IN students.id%TYPE)AS addr students.address%TYPE;BEGIN SELECT address INTO addr FROM students WHERE ID=stu_id; dbms_output.put_line(addr);END; 执行存储过程 1CALL stu_address('8A17DE17428E45D6E0530100007FABEB'); 仅有输出参数存储过程12345CREATE OR REPLACE PROCEDURE stu_age(stu_age OUT students.age%TYPE)ASBEGIN SELECT age INTO stu_age FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB';END; 需要注意的是，此种存储过程不能直接通过call来调用，需要通过一下方式执行 注意，如果通过这种方式执行存储过程，要记得在存储过程中添加输出语句，不然的话，纵然执行成功，也没有结果输出。dbms_output.put_line(stu_age); 12345DECLAREstuage students.age%TYPE;BEGIN stu_age(stuage);END; 或者通过oracle函数调用带有输出参数的存储过程 12345CREATE OR REPLACE FUNCTION get_stuage(stuage OUT NUMBER) RETURN NUMBER ISBEGIN stu_age(stuage); RETURN stuage;END; 执行函数 12345DECLARE stuage students.age%TYPE;BEGIN dbms_output.put_line('return result:' || get_stuage(stuage));END; 既有输入又有输出参数的存储过程12345CREATE OR REPLACE PROCEDURE stu_name(stuid IN students.id%TYPE, stuname OUT students.name%TYPE)ASBEGIN SELECT NAME INTO stuname FROM students WHERE ID=stuid;END; 新建存储函数调用存储过程 12345CREATE OR REPLACE FUNCTION get_stuname(stuid IN students.id%TYPE, stuname OUT students.name%TYPE) RETURN VARCHAR2 ISBEGIN stu_name(stuid, stuname); RETURN stuname;END; 执行函数 12345DECLARE stuname students.name%TYPE;BEGIN dbms_output.put_line('The student name is:' || get_stuname('8A17DE17428E45D6E0530100007FABEB', stuname));END; Java调用存储过程Java调用仅有输出参数的存储过程针对存储过程 stu_age 12345CREATE OR REPLACE PROCEDURE stu_age(stu_age OUT students.age%TYPE)ASBEGIN SELECT age INTO stu_age FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB';END; Java代码如下： 123456789101112131415private void OnlyOutputProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = \"&#123;call stu_age(?)&#125;\"; CallableStatement statement = connection.prepareCall(sql); statement.registerOutParameter(1, OracleTypes.NUMBER); statement.execute(); System.out.println(statement.getInt(1)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; Java调用既有输入参数又有输出参数的存储过程针对存储过程 stu_name 12345CREATE OR REPLACE PROCEDURE stu_name(stuid IN students.id%TYPE, stuname OUT students.name%TYPE)ASBEGIN SELECT NAME INTO stuname FROM students WHERE ID=stuid;END; Java代码如下： 12345678910111213141516private void InAndOutputProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = \"&#123;call stu_name(?,?)&#125;\"; CallableStatement statement = connection.prepareCall(sql); statement.setString(1, \"8A17DE17428E45D6E0530100007FABEB\"); statement.registerOutParameter(2, OracleTypes.VARCHAR); statement.execute(); System.out.println(statement.getString(2)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 以上是有OUT输出参数的存储过程，Java在调用存储过程后还会获得存储过程返回的参数。那么如果存储过程没有OUT输出参数怎么办？ Java调用仅有输入参数的存储过程1234567891011121314private void OnlyInputProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = \"&#123;call stu_address(?)&#125;\"; CallableStatement statement = connection.prepareCall(sql); statement.setString(1, \"8A17DE17428E45D6E0530100007FABEB\"); statement.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; Java调用无参的存储过程12345678910111213private void NoParameterProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = \"&#123;call stu_school()&#125;\"; CallableStatement statement = connection.prepareCall(sql); statement.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; Java调用存储函数创建一个存储函数 get_address 调用 123456create or replace function get_address(stuid in students.id%type) return varchar2 isstuaddress students.address%type;begin select address into stuaddress from students where id=stuid; return stuaddress;end; Java调用存储过程： 12345678910111213141516private void NoParameterProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = \"&#123;?=call get_address(?)&#125;\"; CallableStatement statement = connection.prepareCall(sql); statement.registerOutParameter(1, Types.VARCHAR); statement.setString(2, \"8A17DE17428E45D6E0530100007FABEB\"); statement.execute(); System.out.println(statement.getString(1)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 这里有一个关于Oracle存储过程的PPT文档，供大家下载学习点击下载","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Oracle 存储过程","slug":"Oracle-存储过程","permalink":"http://yoursite.com/tags/Oracle-存储过程/"}]},{"title":"Hello World","slug":"hello-world","date":"2013-07-13T12:46:25.000Z","updated":"2020-01-14T10:12:33.262Z","comments":true,"path":"2013/07/13/hello-world/","link":"","permalink":"http://yoursite.com/2013/07/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"},{"name":"world","slug":"world","permalink":"http://yoursite.com/tags/world/"}]}]}