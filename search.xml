<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Oracle触发器的实现（二）]]></title>
    <url>%2F2019%2F05%2F30%2FOracle%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在上一篇文章Oralce触发器的实现简单的实现了一个触发器，这篇文章会稍加复杂一点。 需求描述： 有一张students 的表，当表中如果插入（新增）一条数据的时候，在新增的那条数据的 remarks 字段中添加This is a new data 的备注；如果修改了一条数据，那么就把这条数据插入到 students_updated 这张表，并添加数据的修改时间。 创建一个测试表 students 表 123456789CREATE TABLE student( ID VARCHAR2(50) DEFAULT sys_guid() PRIMARY KEY, name VARCHAR(20), age NUMBER(4,1), school VARCHAR2(100), grade VARCHAR2(50), address VARCHAR2(500)， remarks VARCHAR2(500)); 插入一条测试数据（这步无所谓，可以先不要测试数据也可以） 1INSERT INTO students (NAME, age, school, grade, address) VALUES (&apos;xiaoming&apos;, &apos;20&apos;, &apos;Changchun University of Architecture&apos;, &apos;Junior&apos;, &apos;Changchun, Jilin&apos;); 在新建 students_updated 表 1234567891011CREATE TABLE students_updated( ID VARCHAR2(50) DEFAULT sys_guid() PRIMARY KEY, student_id VARCHAR2(50), name VARCHAR(20), age NUMBER(4,1), school VARCHAR2(100), grade VARCHAR2(50), address VARCHAR2(500), remarks VARCHAR2(500), ts CHAR(19)); 接下来创建触发器 12]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle 触发器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解线程安全]]></title>
    <url>%2F2019%2F05%2F28%2F%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[转自 编程新说李新杰 不是线程的安全面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。 论语中有句话叫“学而优则仕”，相信很多人都觉得是“学习好了可以做官”。然而，这样理解却是错的。切记望文生义。 同理，“线程安全”也不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。 目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。 在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。 假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。 比如把你住的小区看作一个进程，小区里的道路/绿化等就属于公共区域。你拿1万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。 因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。 所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。 即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程“破坏”。 那我们该怎么办呢？解决问题的过程其实就是一个取舍的过程，不同的解决方案有不同的侧重点。 私有的东西就不该让别人知道现实中很多人都会把1万块钱藏着掖着，不让无关的人知道，所以根本不可能扔到大马路上。因为这钱是你的私有物品。 在程序中也是这样的，所以操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问。这也是由操作系统保障的。 如果一些数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。较为常见的就是局部变量。 123456789double avgScore(double[] scores) &#123; double sum = 0; for (double score : scores) &#123; sum += score; &#125; int count = scores.length; double avg = sum / count; return avg;&#125; 这里的变量sum，count，avg都是局部变量，它们都会被分配在线程栈内存中。 假如现在A线程来执行这个方法，这些变量会在A的栈内存分配。与此同时，B线程也来执行这个方法，这些变量也会在B的栈内存中分配。 也就是说这些局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。 就像每个人的家只属于自己，其他人不能进来。所以你把1万块钱放到家里，其他人是不会知道的。且一般还会放到某个房间里，而不是仍在客厅的桌子上。 所以把自己的东西放到自己的私人地盘，是安全的，因为其他人无法知道。而且越隐私的地方越好。 大家不要抢，人人有份相信聪明的你已经发现，上面的解决方案是基于“位置”的。因为你放东西的“位置”只有你自己知道（或能到达），所以东西是安全的，因此这份安全是由“位置”来保障的。 在程序里就对应于方法的局部变量。局部变量之所以是安全的，就是因为定义它的“位置”是在方法里。这样一来安全是达到了，但是它的使用范围也就被限制在这个方法里了，其它方法想用也不用了啦。 现实中往往会有一个变量需要多个方法都能够使用的情况，此时定义这个变量的“位置”就不能在方法里面了，而应该在方法外面。即从（方法的）局部变量变为（类的）成员变量，其实就是“位置”发生了变化。 那么按照主流编程语言的规定，类的成员变量不能再分配在线程的栈内存中，而应该分配在公共的堆内存中。其实也就是变量在内存中的“位置”发生了变化，由一个私有区域来到了公共区域。因此潜在的安全风险也随之而来。 那怎么保证在公共区域的东西安全呢？答案就是，大家不要抢，人人有份。设想你在街头免费发放矿泉水，来了1万人，你却只有1千瓶水，结果可想而知，一拥而上，场面失守。但如果你有10万瓶水，大家一看，水多着呢，不用着急，一个个排着队来，因为肯定会领到。 东西多了，自然就不值钱了，从另一个角度来说，也就安全了。大街上的共享单车，现在都很安全，因为太多了，到处都是，都长得一样，所以连搞破坏的人都放弃了。因此要让一个东西安全，就疯狂的copy它吧。 回到程序里，要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。相信你已经猜到了，我要表达的就是ThreadLocal类了。 123456789101112131415161718192021222324252627282930313233343536373839class StudentAssistant &#123; ThreadLocal&lt;String&gt; realName = new ThreadLocal&lt;&gt;(); ThreadLocal&lt;Double&gt; totalScore = new ThreadLocal&lt;&gt;(); String determineDegree() &#123; double score = totalScore.get(); if (score &gt;= 90) &#123; return "A"; &#125; if (score &gt;= 80) &#123; return "B"; &#125; if (score &gt;= 70) &#123; return "C"; &#125; if (score &gt;= 60) &#123; return "D"; &#125; return "E"; &#125; double determineOptionalcourseScore() &#123; double score = totalScore.get(); if (score &gt;= 90) &#123; return 10; &#125; if (score &gt;= 80) &#123; return 20; &#125; if (score &gt;= 70) &#123; return 30; &#125; if (score &gt;= 60) &#123; return 40; &#125; return 60; &#125;&#125; 这个学生助手类有两个成员变量，realName和totalScore，都是ThreadLocal类型的。每个线程在运行时都会拷贝一份存储到自己的本地。 A线程运行的是“张三”和“90”，那么这两个数据“张三”和“90”是存储到A线程对象（Thread类的实例对象）的成员变量里去了。假设此时B线程也在运行，是“李四”和“85”，那么“李四”和“85”这两个数据是存储到了B线程对象（Thread类的实例对象）的成员变量里去了。 线程类（Thread）有一个成员变量，类似于Map类型的，专门用于存储ThreadLocal类型的数据。从逻辑从属关系来讲，这些ThreadLocal数据是属于Thread类的成员变量级别的。从所在“位置”的角度来讲，这些ThreadLocal数据是分配在公共区域的堆内存中的。 说的直白一些，就是把堆内存中的一个数据复制N份，每个线程认领1份，同时规定好，每个线程只能玩自己的那份，不准影响别人的。 需要说明的是这N份数据都还是存储在公共区域堆内存里的，经常听到的“线程本地”，是从逻辑从属关系上来讲的，这些数据和线程一一对应，仿佛成了线程自己“领地”的东西了。其实从数据所在“位置”的角度来讲，它们都位于公共的堆内存中，只不过被线程认领了而已。这一点我要特地强调一下。 其实就像大街上的共享单车。原来只有1辆，大家抢着骑，老出问题。现在从这1辆复制出N辆，每人1辆，各骑各的，问题得解。共享单车就是数据，你就是线程。骑行期间，这辆单车从逻辑上来讲是属于你的，从所在位置上来讲还是在大街上这个公共区域的，因为你发现每个小区大门口都贴着“共享单车，禁止入门”。哈哈哈哈。 共享单车是不是和ThreadLocal很像呀。再重申一遍，ThreadLocal就是，把一个数据复制N份，每个线程认领一份，各玩各的，互不影响。 只能看，不能摸放在公共区域的东西，只是存在潜在的安全风险，并不是说一定就不安全。有些东西虽然也在公共区域放着，但也是十分安全的。比如你在大街上放一个上百吨的石头雕像，就非常安全，因为大家都弄不动它。 再比如你去旅游时，经常发现一些珍贵的东西，会被用铁栅栏围起来，上面挂一个牌子，写着“只能看，不能摸”。当然可以国际化一点，“only look，don’t touch”。这也是很安全的，因为光看几眼是不可能看坏的。 回到程序里，这种情况就属于，只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了。 1234class StudentAssistant &#123; final double passScore = 60;&#125; 比如把及格分数设定为60分，在前面加上一个final，这样所有线程都动不了它了。这就很安全了。 小节一下：以上三种解决方案，其实都是在“耍花招”。 第一种，找个只有自己知道的地方藏起来，当然安全了。 第二种，每人复制1份，各玩各的，互不影响，当然也安全了。 第三种，更狠了，直接规定，只能读取，禁止修改，当然也安全了。 是不是都在“避重就轻”呀。如果这三种方法都解决不了，该怎么办呢？Don’t worry，just continue reading。 没有规则，那就先入为主前面给出的三种方案，有点“理想化”了。现实中的情况其实是非常混乱嘈杂的，没有规则的。 比如在中午高峰期你去饭店吃饭，进门后发现只剩一个空桌子了，你心想先去点餐吧，回来就坐这里吧。当你点完餐回来后，发现已经被别人捷足先登了。 因为桌子是属于公共区域的物品，任何人都可以坐，那就只能谁先抢到谁坐。虽然你在人群中曾多看了它一眼，但它并不会记住你容颜。 解决方法就不用我说了吧，让一个人在那儿看着座位，其它人去点餐。这样当别人再来的时候，你就可以理直气壮的说，“不好意思，这个座位，我，已经占了”。 我再次相信聪明的你已经猜到了我要说的东西了，没错，就是（互斥）锁。 回到程序里，如果公共区域（堆内存）的数据，要被多个线程操作时，为了确保数据的安全（或一致）性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说吧。 假设一个线程来到数据跟前一看，发现锁是空闲的，没有人持有。于是它就拿到了这把锁，然后开始操作数据，干了一会活，累了，就去休息了。 这时，又来了一个线程，发现锁被别人持有着，按照规定，它不能操作数据，因为它无法得到这把锁。当然，它可以选择等待，或放弃，转而去干别的。 第一个线程之所以敢大胆的去睡觉，就是因为它手里拿着锁呢，其它线程是不可能操作数据的。当它回来后继续把数据操作完，就可以把锁给释放了。锁再次回到空闲状态，其它线程就可以来抢这把锁了。还是谁先抢到锁谁操作数据。 1234567891011121314151617class ClassAssistant &#123; double totalScore = 60; final Lock lock = new Lock(); void addScore(double score) &#123; lock.obtain(); totalScore += score; lock.release(); &#125; void subScore(double score) &#123; lock.obtain(); totalScore -= score; lock.release(); &#125;&#125; 假定一个班级的初始分数是60分，这个班级抽出10名学生来同时参加10个不同的答题节目，每个学生答对一次为班级加上5分，答错一次减去5分。因为10个学生一起进行，所以这一定是一个并发情形。 因此加分和减分这两个方法被并发的调用，它们共同操作总分数。为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。 相信世界充满爱，即使被伤害再回到一开始的例子，假如你往地上仍1万块钱，是不是一定会丢呢？这要看情况了，如果是在人来人往的都市，可以说肯定会丢的。如果你跑到无人区扔地上，可以说肯定不会丢。 可以看到，都是把东西无保护的放到公共区域里，结果却相差很大。这说明安全问题还和公共区域的环境状况有关系。 比如我把数据放到公共区域的堆内存中，但是始终都只会有1个线程，也就是单线程模型，那这数据肯定是安全的。 再者说，2个线程操作同一个数据和200个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，线程越少数据不安全的概率越小。取个极限情况，那就是只有1个线程，那不安全概率就是0，也就是安全的。 可能你又猜到了我想表达的内容了，没错，就是CAS。可能大家觉得既然锁可以解决问题，那就用锁得了，为啥又冒出了个CAS呢？ 那是因为锁的获取和释放是要花费一定代价的，如果在线程数目特别少的时候，可能根本就不会有别的线程来操作数据，此时你还要获取锁和释放锁，可以说是一种浪费。 针对这种“地广人稀”的情况，专门提出了一种方法，叫CAS（Compare And Swap）。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用CAS。 假如一个线程操作数据，干了一半活，累了，想要去休息。（貌似今天的线程体质都不太好）。于是它记录下当前数据的状态（就是数据的值），回家睡觉了。 醒来后打算继续接着干活，但是又担心数据可能被修改了，于是就把睡觉前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明自己在睡觉期间，数据没有被人动过（当然也有可能是先被改成了其它，然后又改回来了，这就是ABA问题了），那就接着继续干。如果不一样，说明数据已经被修改了，那之前做的那些操作其实都白瞎了，就干脆放弃，从头再重新开始处理一遍。 所以CAS这种方式适用于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。如果并发量很高的话，你的数据一定会被修改，每次都要放弃，然后从头再来，这样反而花费的代价更大了，还不如直接加锁呢。 这里再解释下ABA问题，假如你睡觉前数据是5，醒来后数据还是5，并不能肯定数据没有被修改过。可能数据先被修改成8然后又改回到5，只是你不知道罢了。对于这个问题，其实也很好解决，再加一个版本号字段就行了，并规定只要修改数据，必须使版本号加1。 这样你睡觉前数据是5版本号是0，醒来后数据是5版本号是0，表明数据没有被修改。如果数据是5版本号是2，表明数据被改动了2次，先改为其它，然后又改回到5。 我再次相信聪明的你已经发现了，这里的CAS其实就是乐观锁，上一种方案里的获取锁和释放锁其实就是悲观锁。乐观锁持乐观态度，就是假设我的数据不会被意外修改，如果修改了，就放弃，从头再来。悲观锁持悲观态度，就是假设我的数据一定会被意外修改，那干脆直接加锁得了。 作者观点：前两种属于隔离法，一个是位置隔离，一个是数据隔离。 然后两种是标记法，一个是只读标记，一个是加锁标记。 最后一种是大胆法，先来怼一把试试，若不行从头再来。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式的7种写法]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%847%E7%A7%8D%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[文章转自公众号无敌码农 | 谁要是再问你单例模式，那就抛给他这7种写法吧！ 单例设计模式是23种设计模式中，最基础也是最常用的设计模式之一，也是面试中关于设计模式知识点考察比较高频的问题之一。说起单例模式的写法，大多数情况下出现在我们脑海中的可能就是“饿汉式”，“懒汉式”这两种写法，但是今天小码哥今天要介绍的是单例模式的7种写法，以后面试官要是再问你单例模式，那就抛给他这七种写法吧！ 接下来，我们就言归正传，来一一介绍这七种单例模式的写法吧！ 饿汉式饿汉式是单例模式设计中比较经典的实现方式。实现代码如下： 1234567891011121314151617//final不允许被继承public final class SingleTonEhangshi &#123; //实例变量 private byte[] data = new byte[1024]; //在定义实例对象时直接初始化 private static SingleTonEhangshi instance = new SingleTonEhangshi(); //私有化构造函数，不允许外部NEW private SingleTonEhangshi() &#123; &#125; public static SingleTonEhangshi getInstance() &#123; return instance; &#125;&#125; 饿汉式的实现关键在于instance作为类变量直接得到了初始化，如果我们主动使用SingleToEhangshi类，那么instance实例将会直接完成创建，包括其中的实例变量也都会得到初始化。 instance作为类变量，在类初始化的过程中会被收集进&lt;clinit>()方法中，而该方法是可以100%地保证同步，也就是说instance在多线程的情况下不可能被初始化两次。但是由于instance被ClassLoader加载后很长一段时间才被使用的话，那就会意味着instance实例所开辟的堆内存会驻留很长的时间。 总体说来，如果一个类中的成员变量比较少，且占用的内存资源也不多，用饿汉式的方式实现单例模式也未尝不可，只是其无法进行懒加载。 懒汉式所谓懒汉式就是在使用类实例的时候再去创建，也就是说用到的时候我再创建，这样就可以避免类在初始化的时候提前创建过早地占用内存空间。实现代码如下： 1234567891011121314151617181920//final不允许被继承public final class SingleTonLhangshi &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static SingleTonLhangshi instance = null; //私有化构造函数，不允许外部NEW private SingleTonLhangshi() &#123; &#125; public static SingleTonLhangshi getInstance() &#123; if (null == instance) &#123; instance = new SingleTonLhangshi(); &#125; return instance; &#125;&#125; 类变量instance=null,因此当类被初始化的时候instance并不会立刻被实例化，而是在getInstance()方法被调用时判断instance实例是否被实例化，如果没有实例化在调用私有构造方法进行实例化操作。 懒汉式写法在多线程环境下，会存在同一时间多个线程同时看到null==instance的情况，从而导致instance会被实例化多次，从而无法保证单例的唯一性。 懒汉式＋同步方法懒汉式的单例实现方式可以保证实例的懒加载，但是却无法保证实例的唯一性。在多线程环境下由于instance为共享数据，当多个线程访问使用时，需要保证数据的同步性，所以如果需要保证懒汉式实例的唯一性，我们可以通过同步的方式来实现。代码如下：123456789101112131415161718192021//final不允许被继承public final class SingleTonLhangshiSync &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static SingleTonLhangshiSync instance = null; //私有化构造函数，不允许外部NEW private SingleTonLhangshiSync() &#123; &#125; //向getInstance方法加入同步控制，每次只能有一个线程能够进入 public static synchronized SingleTonLhangshiSync getInstance() &#123; if (null == instance) &#123; instance = new SingleTonLhangshiSync(); &#125; return instance; &#125;&#125; 采用懒汉式＋数据同步的方法既满足了懒加载又能够100%保证instance实例的唯一性。但是，synchronized关键字的排它性会导致getInstance()方法同一时刻只能被一个线程访问，性能会比较低下。 Double-CheckDouble-Check是一种比较聪明的设计方式，它提供了一种高效的数据同步策略，那就是首次初始化的时候加锁，之后则允许多个线程同时进行getInstance()方法的调用来获得类的实例。代码如下：12345678910111213141516171819202122232425262728293031//final不允许被继承public final class SingletonDoubleCheck &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static SingletonDoubleCheck instance = null; Connection con; Socket socket; //私有化构造函数，不允许外部NEW private SingletonDoubleCheck(Connection con, Socket socket) &#123; this.con = con;//初始化 this.socket = socket;//初始化 &#125; public static SingletonDoubleCheck getInstance() &#123; //当instance为null时，进入同步代码块，同时该判断避免了每次都需要进入同步代码块，可以提高效率 if (null == instance) &#123; //只有一个线程能够获得SingletonDoubleCheck.class关联的monitor synchronized (SingletonDoubleCheck.class) &#123; //判断如果instance为null则创建 if (null == instance) &#123; instance = new SingletonDoubleCheck(); &#125; &#125; &#125; return instance; &#125;&#125; 当两个线程发现null==instance成立时，只有一个线程有资格进入同步代码块，完成对instance的初始化，随后的线程发现null==instance不成立则无须进行任何操作，以后对getInstance的访问就不会再需要进行数据同步了。 此种方式看起来是既满足了懒加载，又保证了instance实例的唯一性，并且还提供了比较高效的数据同步策略，可以允许多个线程同时对getInstance进行访问。但是这种方式在多线程的情况下，可能会引起空指针异常，这是因为如果在如上代码的构造方法中还存在初始化其他资源的情况的话，由于JVM运行时存在指令重排的情况，这些资源在实例化时顺序并无前后关系的约束，那么在这种情况下，就极有可能是instance最先被实例化，而con和socket并未完成实例化，而未完成实例化的实例在调用其方法时将会抛出空指针异常。 Volatile+Double-Check为了解决Double-Check指令重排导致的空指针问题，可以用volatile关键字防止这种重排序的发生。因此代码只需要稍作修改就能满足多线程下的单例、懒加载以及实例的高效性了。代码如下：1234567891011121314151617181920212223242526272829303132//final不允许被继承public final class SingletonDoubleCheck &#123; //实例变量 private byte[] data = new byte[1024]; //定义实例，但是不直接初始化 private static volatile SingletonDoubleCheck instance = null; Connection con; Socket socket; //私有化构造函数，不允许外部NEW private SingletonDoubleCheck(Connection con, Socket socket) &#123; this.con = con;//初始化 this.socket = socket;//初始化 &#125; public static SingletonDoubleCheck getInstance() &#123; //当instance为null时，进入同步代码块，同时该判断避免了每次都需要进入同步代码块，可以提高效率 if (null == instance) &#123; //只有一个线程能够获得SingletonDoubleCheck.class关联的monitor synchronized (SingletonDoubleCheck.class) &#123; //判断如果instance为null则创建 if (null == instance) &#123; instance = new SingletonDoubleCheck(); &#125; &#125; &#125; return instance; &#125;&#125; Holder方式Holder方式完全借助了类加载的特点。代码如下：12345678910111213141516171819//不允许被继承public final class SingletonHolder &#123; //实例变量 private byte[] data = new byte[1024]; private SingletonHolder() &#123; &#125; //在静态内部类中持有单例类的实例，并且可直接被初始化 private static class Holder &#123; private static SingletonHolder instance = new SingletonHolder(); &#125; //调用getInstance方法，事实上是获得Holder的instance静态属性 public static SingletonHolder getInstance() &#123; return Holder.instance; &#125;&#125; 在单例类中并没有instance的静态成员，而是将其放到了静态内部类Holder之中，因此单例类在初始化的过程中并不会创建SingletonHolder的实例，内部类Holder中定义了SingletonHolder的静态变量，并且直接进行了实例化，只有当Holder被主动引用的时候才会创建SingletonHolder的实例。 SingletonHolder实例的创建过程在Java程序编译时期收集至&lt;clinit>()方法中，该方法又是同步方法，可以保证内存的可见性、JVM指令的顺序性和原子性。Holder方式的单例模式设计是最好的设计之一，也是目前使用比较广的设计。 枚举方式枚举方式在很多开源框架中也应用得比较广泛，枚举类型不允许被继承，同样是线程安全的，并且只能被实例化一次，但是枚举类型不能够实现懒加载。用枚举类型，实现单例模式的代码如下：1234567891011121314151617181920212223242526public class SingletonEnum &#123; //实例变量 private byte[] data = new byte[1024]; private SingletonEnum() &#123; &#125; //使用枚举充当Holder private enum EnumHolder &#123; INSTANCE; private SingletonEnum instance; EnumHolder() &#123; this.instance = new SingletonEnum(); &#125; private SingletonEnum getInstance() &#123; return instance; &#125; &#125; public static SingletonEnum getInstance() &#123; return EnumHolder.INSTANCE.getInstance(); &#125;&#125; 以上就是要给大家介绍的单例模式的7种写法了，虽然单例模式非常简单，但是在多线程的情况下，我们之前所设计的单例程序未必能够满足单实例、懒加载以及高性能的特点。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux定时任务]]></title>
    <url>%2F2019%2F04%2F28%2FLinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[文章转自 菜鸟教程 inux内置的cron进程能帮我们实现这些需求，cron搭配shell脚本，非常复杂的指令也没有问题。 cron介绍我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。 /var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名 /etc/crontab 这个文件负责调度各种管理和维护任务。 /etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。 我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。 crontab的使用我们常用的命令如下： 1234crontab [-u username] //省略用户表表示操作当前用户的crontab -e (编辑工作表) -l (列出工作表里的命令) -r (删除工作作) 我们用 crontab -e 进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。 crontab的命令构成为 时间+动作，其时间有 分、时、日、月、周 五种，操作符有 * 取值范围内的所有数字 / 每过多少个数字 - 从X到Z ，散列数字 实例实例1：每1分钟执行一次myCommand1* * * * * myCommand 实例2：每小时的第3和第15分钟执行13,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行13,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行13,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行13,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb130 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb145 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb110 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb10,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb10 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb1* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb1* 23-7/1 * * * /etc/init.d/smb restar]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle通过expdp导出/impdp导入]]></title>
    <url>%2F2019%2F04%2F20%2FOracle%E9%80%9A%E8%BF%87expdp%E5%AF%BC%E5%87%BA-impdp%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[EXP和IMP是客户端工具程序，它们既可以在客户端使用，也可以在服务端使用。EXPDP和IMPDP是服务端的工具程序，他们只能在ORACLE服务端使用，不能在客户端使用。IMP只适用于EXP导出的文件，不适用于EXPDP导出文件；IMPDP只适用于EXPDP导出的文件，而不适用于EXP导出文件。 创建逻辑目录逻辑目录用于存放导出的dmp数据文件和log日志文件 查看逻辑目录1SELECT * FROM dba_directories; 新增逻辑目录如果不想用上面查到的已有的逻辑目录，可以自己新增 1CREATE directory DUMP_NAME AS &apos;/home/dump_name&apos;; 目录名称和路径自己定义 为目录文件夹赋予修改和读取的权限1GRANT read, write on directory DUMP_NAME to NC63PM_PEIXUN1; expdp导出数据导出NC63PM_PEIXUN1用户下的数据 1expdp NC63PM_PEIXUN1/NC63PM_PEIXUN1@192.168.18.49/erp directory=DUMP_NAME dumpfile=peixun190420.dmp logfile=peixun190420.log impdp导入数据1impdp soctt/tiger remap_schema=NC63PM_PEIXUN1:soctt dumpfile=peixun190420.dmp Logfile=peixun190420.log directory=backup]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>expdp</tag>
        <tag>impdp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle更改用户名和密码]]></title>
    <url>%2F2019%2F04%2F19%2FOracle%E6%9B%B4%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1、用sysdba账号登入数据库，然后查询到要更改的用户信息：1&gt; SELECT user#,name FROM user$; 2、更改用户名并提交：1&gt; UPDATE USER$ SET NAME=&apos;PORTAL&apos; WHERE user#=88; 1&gt; COMMIT; 3、强制刷新：1&gt; ALTER SYSTEM CHECKPOINT; 1&gt; ALTER SYSTEM FLUSH SHARED_POOL; 4、更新用户的密码：1&gt; ALTER USER PORTAL IDENTIFIED BY 123;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看和修改PATH环境变量的方法]]></title>
    <url>%2F2019%2F04%2F18%2FLinux%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9PATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[查看PATH：1echo $PATH 修改方法一：1export PATH=/usr/local/mongodb/bin:$PATH 配置完后可以通过echo $PATH查看配置结果。 生效方法：立即生效有效期限：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置用户局限：仅对当前用户 修改方法二： 通过修改.bashrc文件: 1vim ~/.bashrc 在最后一行添上： 1export PATH=/usr/local/mongodb/bin:$PATH 生效方法：（有以下两种）1、关闭当前终端窗口，重新打开一个新终端窗口就能生效2、输入“source ~/.bashrc”命令，立即生效有效期限：永久有效用户局限：仅对当前用户 修改方法三:通过修改profile文件: 1vim /etc/profile /export PATH //找到设置PATH的行，添加 1export PATH=/usr/local/mongodb/bin:$PATH 生效方法：系统重启有效期限：永久有效用户局限：对所有用户 修改方法四:通过修改environment文件: 1vim /etc/environment 在 1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot; 中加入 1&quot;:/usr/local/mongodb/bin&quot; 生效方法：系统重启有效期限：永久有效用户局限：对所有用户 文章转自https://www.cnblogs.com/hust-chenming/p/4943268.html]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PATH环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle的一些故障处理]]></title>
    <url>%2F2019%2F04%2F08%2FOracle%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[这里汇总了一些在使用Oracle过程中遇到的问题及解决办法，一方面做为笔记帮助自己以后更快速处理问题，一方面分享处理供大家互相学习。 ⚪SP2-0667: Message file sp1.msb not found 出错原因：crontab里面的脚本，通常读取的是默认的环境变量，PATH里面不包含oracle数据库的路径。 解决办法：1vim ~/.bashrc 把一下内容填写其中 12export ORACLE_HOME=/u01/app/oracle/product/11.2.0/dbhome_1export PATH=$ORACLE_HOME/bin:$PATH 注意，ORACLE_HOME的路径要是你计算机中oracle真实的安装地址 环境变量设置完成，执行 source ~/.bashrc 使其生效。 ⚪ORA-12162: TNS:net service name is incorrectly specified 一般出现这种错误，基本都是环境变量配置有问题，要么是没有配置正确的ORACLE_SID、ORACLE_HOME，要么是监听配置环境变量和.bash_profile环境变量配置不一致。 这里检查发现，是操作系统环境变量没有配置ORACLE_SID 因此，我们配置一下 ~/.bashrc ，在其中添加ORACLE_SID 1export ORACLE_SID=erp 注意：ORACLE_SID的值要根据自己安装oracle时设置的为准 ⚪ORA-04021: timeout occurred while waiting to lock object情景描述:Oracle中本来有个用户NC63PM_PEIXUN1，我把这个用户名更改为了NC63PM_PEIXUN2（更改方法请参考【Oracle更改用户名和密码】），之后我想按照旧的用户名再创建一个用户，但是创建的用户的SQL语句执行了十五分钟还没执行完，并报如下的错误： 解决办法查看是否被锁表了 123&gt; SELECT object_name,machine,s.sid,s.serial#&gt; FROM v$locked_object l,dba_objects o ,v$session s&gt; WHERE l.object_id=o.object_id AND l.session_id=s.sid; 发现没有被锁表 使用 DBA_DDL_LOCKS视图获得DDL锁定信息 1&gt; SELECT * FROM dba_ddl_locks; 发现有两条关于 NC63PM_PEIXUN1 用户的锁定信息 通过 session_id 找到对应的锁表信息 1&gt; SELECT sid,serial#,status FROM v$session a WHERE a.sid in (829,392); 注：因我是kill掉这两条信息后才截的图，所以 STATUS 才为 KILLED 的。 kill这两条锁表 12&gt; ALTER SYSTEM KILL SESSION &apos;392, 5049&apos;;&gt; ALTER SYSTEM KILL SESSION &apos;829, 25287&apos;; 再次执行创建用户的脚本就能顺利执行。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring之自动装配]]></title>
    <url>%2F2019%2F03%2F31%2FSpring%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Spring由名称自动装配Spring有一下几种装配模式： 默认情况下，通过ref指定装配bean byName - 根据属性名称自动装配 byType - 根据数据类型自动装配 还有两种我暂时没理解，以后再说 那么接下来分别说说这几种自动装配 默认设置新建两个bean 1234567891011package com.assembly.beans;public class School &#123; private String name = "Changchun college of architecture"; public String getName() &#123; return name; &#125;&#125; 123456789101112131415package com.assembly.beans;public class Student &#123; private School school; public School getSchool() &#123; return school; &#125; public void setSchool(School school) &#123; this.school = school; &#125;&#125; 默认设置下，我们通过’ref’属性来连接bean 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Spring-Common.xml --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;bean id="student" class="com.assembly.beans.Student"&gt; &lt;property name="school" ref="school" /&gt; &lt;/bean&gt; &lt;bean id="school" class="com.assembly.beans.School"&gt;&lt;/bean&gt;&lt;/beans&gt; 通过属性名称自动装配按属性名称自动装配，就是指如果一个bean的名称与其他bean属性的名称一样，那么将自动装配它。以下面的xml文件为例： 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Spring-Common.xml --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;bean id="student" class="com.assembly.beans.Student" autowire="byName"&gt;&lt;/bean&gt; &lt;bean id="school" class="com.assembly.beans.School"&gt; &lt;property name="name" value="Changchun college of architecture"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 如果 com.assembly.beans.Student 类中有个属性名称为 ‘school’，那么第二个bean将自动装配到第一个bean中。 12345678package com.assembly.beans;public class School &#123; private String name; //...&#125; 12345678package com.assembly.beans;public class Student &#123; private School school; //...&#125; 运行程序 但是如果 Student 类中的属性方法名为 ‘SCHOOL’，那么将会装配失败 12345678package com.assembly.beans;public class Student &#123; private School SCHOOL; //...&#125; 通过属性类型自动装配按属性类型自动装配是指一个bean的数据类型与其他bean属性的类型相同，则自动装配它。 我们以上面 通过属性名称自动装配 的例子来说明 我们把 School 类做一下修改，把变量 name 的数据类型改成布尔类型 1234567891011121314package com.assembly.beans;public class School &#123; private Boolean name; public Boolean getName() &#123; return name; &#125; public void setName(Boolean name) &#123; this.name = name; &#125;&#125; 修改XML文件，让Spring按照类型自动装配 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Spring-Common.xml --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;bean id="student" class="com.assembly.beans.Student" autowire="byType"&gt;&lt;/bean&gt; &lt;bean id="school" class="com.assembly.beans.School"&gt; &lt;property name="name" value="Changchun college of architecture!!!"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 再次运行程序，会报如下的错误 12345678...Caused by: java.lang.IllegalArgumentException: Invalid boolean value [Changchun college of architecture!!!] at org.springframework.beans.propertyeditors.CustomBooleanEditor.setAsText(CustomBooleanEditor.java:154) at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:466) at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:439) at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:192) at org.springframework.beans.AbstractNestablePropertyAccessor.convertIfNecessary(AbstractNestablePropertyAccessor.java:585) ... 28 more 还有通过注解实现自动装配等的例子，后续会再做补充]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring通过JDBC连接数据库并进行增删改查的操作]]></title>
    <url>%2F2019%2F03%2F31%2FSpring%E9%80%9A%E8%BF%87JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Spring通过JDBC连接MySQL数据库并进行增删改查的操作首先我们在自己的MySQL数据库中建一张学生成绩表，做为我们的测试用例。 1234567CREATE TABLE `students` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT NULL, `math` int(50) DEFAULT NULL, `english` int(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 随便向里面插入一条数据 1INSERT INTO students ('name', 'math', 'english') values ('zhangsan', '80', '75'); 接下来开始新建我们的实例项目，先看看项目目录结构 注意，必要的jar包不要少了 首先对应我们建的学生成绩表新建一个学生成绩模型1234567891011121314151617181920212223242526272829303132333435363738394041package com.jdbc.model;public class Student &#123; private int id; private String name; private int math; private int english; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getMath() &#123; return math; &#125; public void setMath(int math) &#123; this.math = math; &#125; public int getEnglish() &#123; return english; &#125; public void setEnglish(int english) &#123; this.english = english; &#125; public Student(int id, String name, int math, int english) &#123; super(); this.id = id; this.name = name; this.math = math; this.english = english; &#125;&#125; 新建成绩查询的接口，并具体实现它123456789package com.jdbc.itf;import com.jdbc.model.Student;public interface StudentDAO &#123; public Student findByStudentId(int id);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.jdbc.impl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import javax.sql.DataSource;import com.jdbc.itf.StudentDAO;import com.jdbc.model.Student;public class JdbcStudentDAO implements StudentDAO &#123; private DataSource data_source; public void setData_source(DataSource data_source) &#123; this.data_source = data_source; &#125; @Override public Student findByStudentId(int id) &#123; String querySQL = "SELECT * FROM students WHERE id = ?"; Connection conn = null; try &#123; conn = data_source.getConnection(); PreparedStatement ps = conn.prepareStatement(querySQL); ps.setInt(1, id); ResultSet rs = ps.executeQuery(); Student student = null ; if(rs.next()) &#123; student = new Student( rs.getInt("id"), rs.getString("name"), rs.getInt("math"), rs.getInt("english")); &#125; rs.close(); ps.close(); return student; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; 我们注意到，在实现类的开始定义了一个 DataSource 类型的变量 data_source ，用来连接我们的数据库。那么 data_source 具体定义的是什么呢？这个需要我们通过Spring的xml文件向其注入属性。 新建xml文件 mysql数据库的ip地址和账号密码请修改为自己的 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;bean id="studentDAO" class="com.jdbc.impl.JdbcStudentDAO"&gt; &lt;property name="data_source" ref="dataSource" /&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://IP:3306/my?useSSL=false" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt;&lt;/beans&gt; 功能实现一切准备好了，那么我们通过一个主文件来运行它 1234567891011121314151617181920package com.jdbc.main;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.jdbc.itf.StudentDAO;import com.jdbc.model.Student;public class Application &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"); StudentDAO studentDao = (StudentDAO) context.getBean("studentDAO"); Student std = studentDao.findByStudentId(1); System.out.println("Id:"+std.getId()); System.out.println("Name:"+std.getName()); System.out.println("Math:"+std.getMath()); System.out.println("English:"+std.getEnglish()); &#125;&#125; 结果显示： 以上例子仅仅是查询的，那么下面的例子是对增删该查的总体汇总。 首先在接口中把剩余的方法补充上 12345678910111213141516package com.jdbc.itf;import com.jdbc.model.Student;public interface StudentDAO &#123; //查询 public Student findByStudentId(int id); //新增 public void insertNewStudent(Student studnet); //删除 public void deleteByStudentId(int id); //更改 public void updateByStudentId(Student student);&#125; 在接口实现类中实现它们 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.jdbc.impl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import javax.sql.DataSource;import com.jdbc.itf.StudentDAO;import com.jdbc.model.Student;public class JdbcStudentDAO implements StudentDAO &#123; private DataSource data_source; public void setData_source(DataSource data_source) &#123; this.data_source = data_source; &#125; @Override public Student findByStudentId(int id) &#123; String querySQL = "SELECT * FROM students WHERE id = ?"; Connection conn = null; try &#123; conn = data_source.getConnection(); PreparedStatement ps = conn.prepareStatement(querySQL); ps.setInt(1, id); ResultSet rs = ps.executeQuery(); Student student = null ; if(rs.next()) &#123; student = new Student( rs.getInt("id"), rs.getString("name"), rs.getInt("math"), rs.getInt("english")); &#125; rs.close(); ps.close(); return student; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(conn != null) &#123; connClose(conn); &#125; &#125; return null; &#125; @Override public void insertNewStudent(Student studnet) &#123; String insertSQL = "INSERT INTO students (name, math, english) VALUES (?, ?, ?)"; Connection conn = null; try &#123; conn = data_source.getConnection(); PreparedStatement ps = conn.prepareStatement(insertSQL); ps.setString(1, studnet.getName()); ps.setInt(2, studnet.getMath()); ps.setInt(3, studnet.getEnglish()); ps.executeUpdate(); ps.close(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; connClose(conn); &#125; &#125; @Override public void deleteByStudentId(int id) &#123; Connection conn = null; try &#123; String deleteSQL = "DELETE FROM students where id=?"; conn = data_source.getConnection(); PreparedStatement ps = conn.prepareStatement(deleteSQL); ps.setInt(1, id); ps.executeUpdate(); ps.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; connClose(conn); &#125; &#125; @Override public void updateByStudentId(Student student) &#123; Connection conn = null; try &#123; String updateSQL = "UPDATE students SET name=?, math=?, english=? WHERE id=?"; conn = data_source.getConnection(); PreparedStatement ps = conn.prepareStatement(updateSQL); ps.setString(1, student.getName()); ps.setInt(2, student.getMath()); ps.setInt(3, student.getEnglish()); ps.setInt(4, student.getId()); ps.executeUpdate(); ps.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; connClose(conn); &#125; &#125; private void connClose(Connection conn) &#123; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; updateByStudentId方法实现对数据的修改不是最优的，后续会对它进行进一步的优化]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring之松耦合]]></title>
    <url>%2F2019%2F03%2F31%2FSpring%E4%B9%8B%E6%9D%BE%E8%80%A6%E5%90%88%2F</url>
    <content type="text"><![CDATA[Spring松耦合的个人理解和代码实例理解Spring的松耦合概念，那么我们先来看看一个不使用Sring的实例代码 先看一下整个测试项目案例的结构 正常方式创建一个接口，这个接口指定车辆的行驶速度 1234567package com.car.run;public interface SpeedCar &#123; public void runSpeed();&#125; 现在我们指定两辆车的行驶速度：一辆F1赛车，行驶最高速度为300 km/h, 一辆客运大巴，速度为 80 km/h。 12345678910111213//F1赛车package com.car.impl;import com.car.run.SpeedCar;public class F1Racing implements SpeedCar &#123; @Override public void runSpeed() &#123; System.out.println("The maximum speed of the F1 is 300 km/h."); &#125;&#125; 12345678910111213//客运大巴package com.car.impl;import com.car.run.SpeedCar;public class PassengerBus implements SpeedCar &#123; @Override public void runSpeed() &#123; System.out.println("The maximum speed of a passenger bus is 80 km/h."); &#125;&#125; 按正常方式我们直接调用 123456789101112package com.car.main;import com.car.impl.PassengerBus;import com.car.run.SpeedCar;public class Test &#123; public static void main(String[] args) &#123; SpeedCar speedcar = new PassengerBus(); speedcar.runSpeed(); &#125;&#125; 目前来看，其实这种方法也挺简单的，无非就是new 出一个客运大巴的对象 speedcar，然后通过speedcar来输出客运大巴的最高时速。但是我们new出的对象speedcar完全依赖的是客运大巴，或者说对客运大巴的耦合度特别高，它也仅仅是指向客运大巴PassengerBus，如果我们要输出F1赛车的最高时速，那么还需要再次new出F1赛车的对象。 结果显示 通过辅助类实现1234567891011121314151617package com.car.helper;import com.car.impl.PassengerBus;import com.car.run.SpeedCar;public class SpeedCarHelper &#123; SpeedCar speedcar; public SpeedCarHelper()&#123; speedcar = new PassengerBus(); &#125; public void getSpeed() &#123; speedcar.runSpeed(); &#125;&#125; 改造我们上一个方法中主方法实现内容 123456789101112package com.car.main;import com.car.helper.SpeedCarHelper;public class Test &#123; public static void main(String[] args) &#123; SpeedCarHelper helper = new SpeedCarHelper(); helper.getSpeed(); &#125;&#125; 那么实际上这种方法也是一种高耦合，helper依赖与辅助类，而这个辅助类又依赖与客运大巴PassengerBus。 结果显示 Spring实现最后，我们通过Spring的依赖注入，实现生成松散的耦合。 改造辅助类 12345678910111213141516package com.car.helper;import com.car.run.SpeedCar;public class SpeedCarHelper &#123; SpeedCar speedcar; public void setSpeedcar(SpeedCar speedcar) &#123; this.speedcar = speedcar; &#125; public void getSpeed() &#123; speedcar.runSpeed(); &#125;&#125; 创建 Spring bean 的配置文件，并在这里声明所有的Java对象的依赖 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Spring-Common.xml --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;bean id="speedCarHelper" class="com.car.helper.SpeedCarHelper"&gt; &lt;property name="speedcar" ref="F1Racing" /&gt; &lt;/bean&gt; &lt;bean id="F1Racing" class="com.car.impl.F1Racing" /&gt; &lt;bean id="PassengerBus" class="com.car.impl.PassengerBus" /&gt;&lt;/beans&gt; 改造主方法 12345678910111213141516package com.car.main;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.car.helper.SpeedCarHelper;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"); SpeedCarHelper helper = (SpeedCarHelper) context.getBean("speedCarHelper"); helper.getSpeed(); &#125;&#125; 结果显示 现在我们通过beans.xml文件生成指定的输出，如果在后续的工作中我们希望输出客运大巴的最高时速，直接更改xml文件即可，不用修改代码，这样就降低了代码的耦合度。]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识小结]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写这篇文章是为了记录一下学习中被忽略的知识点，这些知识点虽然知道听说过，但对它们的概念和作用都很模糊，如果别人问起为什么，自己还真解释不上来，因此做个记录，方便以后回顾以及大家一起学习。 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会默认生成一个不带参数且没有任何执行动作的构造方法。 在Java中定义一个不做任何事且没有参数的构造方法的作用Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则系统会自动调用父类中没有参数的构造方法。当此时父类中只定义了有参数的构造方法而没有定义无参数的构造方法，然后在子类的构造方法中又没有使用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到无参数的构造方法可供执行。所以我们要在父类里加上一个不做任何事且没有参数的构造方法。 重载和重写的区别重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。 try-catch-finally try块：用于捕获异常。其后可跟零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch块： 用于处理try捕获的异常。 finally块：无论是否捕获或者处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 注意，一下几种情况finally块不会被执行： 1.在finally语句块中发生了异常； 2.在前面的代码中用了System.exit()退出； 3.程序所有的线程死亡； 4.关闭CPU。 final/finally/finalize的区别finalJava中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量） 当用final修饰一个类时，表明这个类不能被继承 当final修饰一个类中的某个方法，这个类的子类不能重写覆盖这个被修饰的类，也就是说子类是不能够存在和父类一模一样的方法。 final修饰变量，该变量表示常量，只能被赋值一次，赋值后值不能被修改。 finally在异常处理时提供finally块来执行清楚操作。论是否捕获或者处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 finalize是方法名。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除之前做必要的清理工作。这个方法是在垃圾收集器在确定了，被清理对象没有被引用的情况下调用的。 finalize是在Object类中定义的，因此，所有的类都继承了它。子类可以覆盖finalize()方法，来整理系统资源或者执行其他清理工作。 HashMapHashMap的特点 HashMap是基于哈希表的Map接口实现的。 HashMap底层采用的是Entry数组和链表实现的。 HashMap是采用key-value形式存储，其中key是可以允许为null，但是只能有一个，并且key不允许重复（如果重复则新值会覆盖旧值）。 HashMap是线程不安全的。 HashMap存入的顺序和遍历的顺序可能不一致（无序）。 HashMap保存数据的时候通过计算key的hash值来决定存储的位置。 HashMap的工作原理是什么？HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。 HashMap源代码要看HashMap的源代码，我们还是从HashMap的构造方法开始一步一步的讲解。 小总结：可以看出HashMap构造的时候会初始化16个容量，并且负载因子是0.75。负载因子是什么呢？我们后面讲。 小总结：这个构造方法没有什么可说的，只是多了些验证。在这里呢？构造方法就算初始化完毕了。 我们知道HashMap最常用的方法也就是put方法了，那么下面我们就着重去探究一下put方法的实现原理，也就是对HashMap的一个透彻理解。 这段代码好好的研读，请仔细往下看： 第一步： 直接判断 table==EMPTY_TABLE ，那么这个table是什么呢？看下图： 那么这个Entry又是说什么东东呢？ 这个Entry是Map的一个静态内部类，里面最重要的属性有key、value和next三个属性值，在这里，我想大家已经猜到了，这个key和value是不是我们put的时候的key和value呢？答案是的，这个next又是干嘛用的呢？实际上这个Entry的的数据结构是一个单链表，这个next的属性的值还是这个Entry，表示的是当前的节点的下一个节点是哪个Entry。 好啦，源代码看到这里，我们知道，在put方法中，直接判断table是否为null，那么很显然到目前为止我们的table肯定是为null的，那么继续看如果table为null则要执行的代码。看下图： 哇塞，可以很直观的看到，我们实际上是初始化了一个Entry数组，而我们HashMap中的数据都是保存在了Entry[]里面了。 小总结：HashMap其实就是一个线性的Entry数组，而在Entry这个对象中保存了key和value，至于Entry对象中的next的具体作用是干嘛的，稍等做介绍哦。 第二步： 判断key是否为null。从这里可以看出，当判断key如果为null的话，并没有抛出什么异常错误，很显然HashMap是支持key为null的。那么就来看看key如果为null，会怎么处理呢？ 小总结：首先去循环遍历这个Entry数组，判断是否有key为null的情况，如果有则新值覆盖掉旧值。如果没有key为null的情况，则hash值为0，数据存储在这个Entry数组的第0个位置，也就是table[0]，具体方法可以查看addEntry方法，在这里呢，我就不再演示了。 第三步： 通过hash方法对key进行计算hash散列值，并且根据这个散列值查找这个要保存的值应该存储到table这个数组中的哪个索引位置。 第四步： 循环变量这个Entry数组，并且判断是否有重复的元素添加进去。 小总结：当去变量这个Entry数组的时候，去判断两个Entry对象的key的hash是否相同则仅仅表示它们的存储位置是相同的，然后继续判断两个Entry的key是否相等或者equals是否相等，如果条件都满足，则表示要添加的元素，key已经重复，则直接将新值覆盖掉旧值，并且return返回，一旦条件不满足，则直接将添加的元素添加到Entry对象中。 好啦，这个就是整个HashMap的底层原理。现在有的朋友可能会有产生这样的问题：如果计算的key的hash值相等，但是equals方法不相等，那么计算出来的要存储的位置不就冲突了吗？那么如果保存呢？ 解决：实际上这种担忧是有必要的，因为我们完全有可能就是说计算的key的hash值和另一个key的hash值是相等的，那么这个时候呢，如果key的equals方法又不相等，那么这个时候我要保存的value值应该存储到table中的哪个索引上呢？实际上，这种情况叫做hash冲突，学习过数据结构的朋友应该都知道，解决hash冲突的方法有很多，但是在Java中，解决冲突的办法是采用的是链表来解决的。还记得这个Entry的next属性吗？对了，这个next属性就是用来记录这个链表上的下一个Entry。 HashMap的内容摘自http://baijiahao.baidu.com/s?id=1601416041995350500&amp;wfr=spider&amp;for=pc volatile关键字的基本作用和原理volatile关键字可以实现线程间的可见性，之所以可以实现这一点，原因在于JVM会保证被volatile修饰的变量，在线程栈中被线程使用时都会主动从共享内存(堆内存/主内存)中以实时的方式同步一次；另一方面，如果线程在工作内存中修改了volatile修饰的变量，也会被JVM要求立马刷新到共享内存中去。因此，即便某个线程修改了该变量，其他线程也可以立马感知到变化从而实现可见性. 未完待续…]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识汇总]]></title>
    <url>%2F2019%2F03%2F15%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案。 对于开发来说，了解和学习Oracle数据库是非常有必要的。 这篇文章仅仅是对Oracle做了一个简单的总结，后续如果用到或接触到的知识点，都会做补充 ⚪查看登陆的用户show user 命令 1SQL&gt; show user ⚪dba_users 数据字典通过 dba_users 这个表查看登陆的用户信息，那么在查询之前我们先看看 dba_users 这个表的表结构，可以通过 desc dba_users 这个命令查看指定表的表结构 1SQL&gt; desc dba_users 可看到该表结构中包含用户名、用户的ID和密码等内容 现在我们查看系统中用户的信息1select * from dba_users; Oracle中 dba_users 和 user_users 都可以查询用户的信息，这两张表都是查看表空间信息的表，它们的区别是：前者是只供管理员用户查询的，后者是管理员用户和普通用户都可以查询的。 ⚪几个典型的用户说明Oracle中有那么几个典型的用户，它们是在安装Oracle的时候默认创建的，分别具有不同的作用。下面我们介绍Oracle中sys,system,scott,hr用户： scott 是个演示用户，是让你学习Oracle用的； hr用户是个示例用户，是在创建数据库时选中“示例数据库”后产生的，实际就是模拟一个人力资源部的数据库； SYSDBA 不是用户，可以认为是个权限，超级权限。默认中sys就拥有这种超级权限，是权限最高的用户。 超级用户分两种 SYSDBA和SYSOPTSYSOPT 后面3个字母是operator的意思，也就是操作数据库的人，而SYSDBA 则是管理数据库的人;SYSDBA比SYSOPT的权限还要大，而SYS用户就完全是个SYSDBA，但SYSTEM用户默认是SYSOPT，不过它也能以SYSDBA的权限登陆。 它们之间的不同之处可以下载Oracle中sys-system-scott-hr用户的区别 这份文档了解学习。 ⚪启动（解锁）被锁定的用户Oracle中有个scott用户默认是被锁定的 如果要解锁它，我们首先需要登陆其他用户，并通过SQL语句alter user scott account unlock;解锁它。 1alter user scott account unlock; scott用户的默认密码为 tiger 接下来通过 ‘connect scott/tiger’ 来登陆scott用户。如果scott用户密码过期的话，系统会提示你更改密码 或者通过SQL语句更改scott用户的密码 1alter user scott identified by tiger; ⚪表空间表空间的分类 永久表空间 存放永久性数据，如表，索引等。 临时表空间 不能存放永久性对象，用于保存数据库排序，分组时产生的临时数据。 UNDO表空间 保存数据修改前的镜象。 查看用户的表空间在前面我们提到的 dba_users 表中有两个字段 DEFAULT_TABLESPACE TEMPORARY_TABLESPACE 这两个字段分别代表用户的默认表空间和临时表空间。 比如我们要查看system用户的默认表空间和临时表空间 查看表空间的信息这里有两张表 dba_tablespaces user_tablespaces 这两张表都是查看表空间信息的表，它们的区别是：前者是只供管理员用户查询的，后者是管理员用户和普通用户都可以查询的。 更改我们指定用户的默认表空间或者临时表空间1ALTER USER username DEFAULT|TEMPORARY TABLESPACE tablespace_name; 新建表空间1CREATE [TEMPORARY] TABLESPACE tablespace_name TEMPFILE|DATAFILE &apos;xxx.dbf&apos; SIZE xxx; 表空间创建完毕后，我们可以查看表空间的位置在哪，比如我们查看表空间名称为SYSTEM的位置 1SELECT file_name FROM dba_data_files WHERE tablespace_name=&apos;SYSTEM&apos;; 注意，如果要查看创建的临时表空间的数据文件的地址，就不能查表 dba_data_files 了，而要查 dba_temp_file 表。 1SELECT file_name FROM dba_temp_files WHERE tablespace_name=&apos;TEMPORARY_TABLESPACE&apos;; 修改表空间的状态设置表空间的联机或脱机状态 1ALTER TABLESPACE tablespace_name ONLINK|OFFLINK; 设置表空间的只读或可读写的状态 1ALTER TABLESPACE tablespace_name READ ONLY|READ WRITE; 表空间为脱机状态，那么系统不允许修改该表空间的读写状态。表空间联机的状态，默认该表空间为可读写的状态。 修改表空间中的数据文件增加数据文件 1ALTER TABLESPACE tablespace_name ADD DATAFILE|TEMPFILE &apos;xxx.dbf&apos; SIZE xxx; 删除数据文件 1ALTER TABLESPACE tablespace_name DROP DATAFILE &apos;filename.dbf&apos;; 删除表空间1DROP TABLESPACE tablespace_name [INCLUDING CONTENTS]; 如果只删除表空间而不删除数据文件，那么不用加上[]里面的内容。 ⚪约束数据的完整性用于确保数据库数据遵从一定的商业和逻辑规则。在Oracle中，数据完整性可以使用约束、触发器、应用程序（过程、函数）三种方法来实现，在这三种方法中，因为约束易于维护，并且具有最好的性能，所以作为维护数据完整性的首选。 约束用于确保数据库数据满足特定的商业规则。在Oracle中，约束包括：not null、unique、primary key， foreign key和check五种。 not null（非空）如果在列上定义了not null，那么当插入数据时，必须为列提供数据。 unique（唯一）当定义了唯一约束后，该列值是不能重复的，但是可以为null。 primary key（主键）用于唯一的标识表行的数据，当定义主键约束后，该列不但不能重复而且不能为NULL。一张表最多只能有一个主键，但是可以由多个unique约束。 foreign key（外键）用于定义主表和从表之间的关系，外键约束要定义在从表上，主要则必须具有主键约束或是unique约束，当定义外键约束后，要求外键列数据必须在主表的主键列存在或是为NULL。 check用于强制行数据必须满足的条件，假定在sal列上定义了check约束，并要求sal列值在1000～2000之间，如果不在1000～2000之间就会提示出错。 ⚪修改表名1ALTER TABLE 旧表名 RENAME TO 新表名;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle实现DBLink]]></title>
    <url>%2F2019%2F03%2F15%2FOracle%E5%AE%9E%E7%8E%B0DBLink%2F</url>
    <content type="text"><![CDATA[在了解DBLink之前，最后我们有一点Oracle方面的基础，可以先看看我的另一篇文章Oracle基础知识汇总]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>DBLink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle去重而保存时间最新的数据]]></title>
    <url>%2F2019%2F01%2F21%2FOracle%E5%8E%BB%E9%87%8D%E8%80%8C%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E6%9C%80%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Oracle去重而保存时间最新的数据 本篇文章仅仅是我工作上的一个随笔记录，写的不是很详细，如果不了解我所做的工作的业务内容，可能会看的一头雾水。大家可以仅做为一种参考思路！ 场景描述： 单据表 fdcpm_pay_apply 中的财务处理状态的值一直是从财务中间表 mid_fina_x 中获取的现在我们在 fdcpm_pay_apply 中添加一个 ifinastatus 的字段用来直接存储财务处理状态的值，并且以后就按照这种方式存储，所以需要把财务中间表中已有的财务处理状态给刷到对应单据的 ifinastatus字段中。 查看表中重复的数据有哪些(去掉重复，只显示单据编码vbillcode)1SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1; 通过上步查询出来的vbillcode，可以查询出所有重复的数据123SELECT * FROM mid_fina WHERE NVL(dr,0)=0 AND vbillcode IN( SELECT vbillcode FROM mid_fina WHERE NVL(dr,0)=0 GROUP BY vbillcode HAVING COUNT(*)&gt;1); 那么我们为了以防万一，复制一张一模一样的表来进行下一步的处理1CREATE TABLE mid_fina_x AS (SELECT * FROM mid_fina WHERE NVL(dr,0)=0); 查询数据中vbillcode相等，但是修改时间比较早的数据123SELECT * FROM mid_fina_x mf WHERE mf.ts &lt; ( SELECT MAX(mx.ts) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 删除这些重复数据中的旧数据，只保留最新的那一条123DELETE FROM mid_fina_x mf WHERE mf.ts &lt; ( SELECT MAX(mx.ts) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 需要注意的是，按上述方法删除重复数据，只会删除时间比最新时间早的数据，如果有两条数据，他们的vbillcode和ts修改时间都是一样的，那么这两条数据都不会被删除，因此我们需要再次过来一次重复数据 前一次过滤是通过ts修改时间，那么这次我们可以选择其他有序的字段进行过滤，毕竟，如果几条数据的vbillcode和ts修改时间都相同的情况下，我们只需要取其中的某一条（不管那一条）数据的paystatus财务处理状态的值 123DELETE FROM mid_fina_x mf WHERE mf.pk_pa_payrefinfo &lt; ( SELECT MAX(mx.pk_pa_payrefinfo) FROM mid_fina_x mx WHERE mf.vbillcode=mx.vbillcode AND NVL(mx.dr,0)=0) AND NVL(mf.dr,0)=0; 那么我们现在得到的 mid_fina_x 表就是没有重复数据的数据表了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle触发器的实现]]></title>
    <url>%2F2019%2F01%2F03%2FOracle%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[触发器的定义就是说某个条件成立的时候，触发器里面所定义的语句就会被自动的执行。因此触发器不需要人为的去调用，也不能调用。触发器分为语句级触发器和行级触发器。语句级触发器可以在某些语句执行前或者执行后触发，而行级触发器是定义指定表中行数据改变时的触发器。 工作中又遇到这样的问题： 一张表pm_cm_payapply中的vreserve14字段，总是不知道在哪步操作中被致为空（原来的值不为空） 于是打算在表中设置一个触发器 触发器实现： 当表被更新时，判断如果vreserve14被更新为空值，则提示报错 触发器内容： 1234567891011CREATE OR REPLACE TRIGGER tri_vreserveAFTER UPDATE OF vreserve14 ON pm_pa_payapplyDECLARE myexp exceptionBEGIN IF old.vreserve14 != &apos;&apos; AND new.vreserve14 == &apos;&apos; THEN RAISE myexp; END IF; EXCEPTION_INIT WHEN myexp THEN raise_application_error(&apos;-20002&apos;,&apos;vreserve14字段的值被设置为空&apos;)；END; 测试： oracle查询触发器 首先我们要知道这个触发器是指向哪个表，比如我们本次是在表 pm_cm_payapply 中写的触发器，那我在 all_trigger 表中通过表明table_name查询触发器名trigger_name 1select trigger_name from all_triggers where table_name=&apos;PM_PA_PAYAPPLY&apos;; 注意，表名要大写 得到触发器名为 tri_vreserve ，再通过触发器名在表all_source 表中查询触发器的具体内容 1select text from all_source where type=&apos;TRIGGER&apos; AND name=&apos;TRI_VRESERVE&apos;; 注意，触发器表名也要大写]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle 触发器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Linux中进程状态的补充说明]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%AF%B9Linux%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[对进程状态的详细说明 这篇文章是对我上一篇文章Linux的ps命令解析的补充 ，重点说明了各进程状态分别代表什么，帮助大家理解ps命令和Linux的程序运行。文章摘自CSDN Linux 进程状态 说明 R (task_running) : 可执行状态只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。 很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为TASK_RUNNING状态。 S (task_interruptible): 可中断的睡眠状态处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。 通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于task_interruptible状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。 D (task_uninterruptible):不可中断的睡眠状态与task_interruptible状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。 绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。但是uninterruptible sleep状态的进程不接受外来的任何信号，因此无法用kill杀掉这些处于D状态的进程，无论是”kill”, “kill -9″还是”kill-15″，这种情况下，一个可选的方法就是reboot。 处于uninterruptible sleep状态的进程通常是在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问了. 而task_uninterruptible状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。 在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用task_uninterruptible状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的task_uninterruptible状态总是非常短暂的，通过ps命令基本上不可能捕捉到。 我们通过vmstat命令中procs下的b可以来查看是否有处于uninterruptible状态的进程。 该命令只能显示数量。 In computer operating systems terminology, a sleeping process can either be interruptible (woken via signals) or uninterruptible (woken explicitly).An uninterruptible sleep state is a sleep state that cannot handle a signal (such as waiting for disk or network IO (input/output)). When the process is sleeping uninterruptibly, the signal will be noticed when the process returns from the system call or trap. 这句是关键。当处于uninterruptibly sleep状态时，只有当进程从system调用返回时，才通知signal。 A process which ends up in “D” state for any measurable length of time is trapped in the midst of a system call (usually an I/O operation on a device — thus the initial in the ps output). Such a process cannot be killed — it would risk leaving the kernel in an inconsistent state, leading to a panic. In general you can consider this to be a bug in the device driver that the process is accessing. T(task_stopped or task_traced)：暂停状态或跟踪状态向进程发送一个sigstop信号，它就会因响应该信号而进入task_stopped状态（除非该进程本身处于task_uninterruptible状态而不响应信号）。（sigstop与sigkill信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。） 向进程发送一个sigcont信号，可以让其从task_stopped状态恢复到task_running状态。 当进程正在被跟踪时，它处于task_traced这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于task_traced状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。 对于进程本身来说，task_stopped和task_traced状态很类似，都是表示进程暂停下来。 而task_traced状态相当于在task_stopped之上多了一层保护，处于task_traced状态的进程不能响应sigcont信号而被唤醒。只能等到调试进程通过ptrace系统调用执行ptrace_cont、ptrace_detach等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复task_running状态。 Z (task_dead - exit_zombie)：退出状态，进程成为僵尸进程在Linux进程的状态中，僵尸进程是非常特殊的一种，它是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。 它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。 进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。 之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。 当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。 子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。 这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。 如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，子进程的尸体（task_struct）也就无法释放掉。 如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。 当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管的进程可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。 linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作； init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于task_interruptible状态，“收尸”过程中则处于task_running状态。 Unix/Linux处理僵尸进程的方法：找出父进程号，然后kill父进程，之后子进程（僵尸进程）会被托管到其他进程，如init进程，然后由init进程将子进程的尸体（task_struct）释放掉。 除了通过ps的状态来查看Zombi进程，还可以用如下命令查看：123[oracle@rac1 ~]$ ps -ef|grep defunoracle 13526 12825 0 16:48 pts/1 00:00:00 grep defunoracle 28330 28275 0 May18 ? 00:00:00 [Xsession] &lt;defunct&gt; 僵尸进程解决办法： （1）改写父进程，在子进程死后要为它收尸。 具体做法是接管SIGCHLD信号。子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行 waitpid()函数为子进程收尸。这是基于这样的原理：就算父进程没有调用wait，内核也会向它发送SIGCHLD消息，尽管对的默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。 （2）把父进程杀掉。 父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。如：1kill -9 `ps -ef | grep &quot;Process Name&quot; | awk &apos;&#123; print $3 &#125;&apos;` 其中，“Process Name”为处于zombie状态的进程名。 （3）杀父进程不行的话，就尝试用skill-t TTY关闭相应终端，TTY是进程相应的tty号(终端号)。但是，ps可能会查不到特定进程的tty号，这时就需要自己判断了。 （4）重启系统，这也是最常用到方法之一。 X (task_dead - exit_dead)：退出状态，进程即将被销毁进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程。或者父进程通过设置sigchld信号的handler为sig_ign，显式的忽略了sigchld信号。（这是posix的规定，尽管子进程的退出信号可以被设置为sigchld以外的其他信号。） 此时，进程将被置于exit_dead退出状态，这意味着接下来的代码立即就会将该进程彻底释放，所以exit_dead状态是非常短暂的，几乎不可能通过ps命令捕捉到。 作者：Dave来源：CSDN原文：https://blog.csdn.net/tianlesoftware/article/details/6457487版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>ps进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle存储过程的实现]]></title>
    <url>%2F2018%2F03%2F03%2FOracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Oracle存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（是否给参数要看该存储过程定义的过程中是否设置了参数）来执行它。 准备工作创建一张测试表 students 12345678910create table STUDENTS( id VARCHAR2(50) default sys_guid() not null, name VARCHAR2(20), age NUMBER(4,1), school VARCHAR2(100), grade VARCHAR2(50), address VARCHAR2(500), remarks VARCHAR2(500), ts CHAR(19) default to_char(sysdate,'yyyy-mm-dd hh24:mi:ss')) 插入一条测试数据。当然，也可以插入自己想插入的内容。 12insert into STUDENTS (id, name, age, school, grade, address, remarks, ts)values ('8A17DE17428E45D6E0530100007FABEB', 'xiaoming', 20, 'Changchun University of Architecture', 'Junior', 'Changchun, Jilin', null, '2019-06-12 11:07:57'); 第一个简单的存储过程123456CREATE OR REPLACE PROCEDURE stu_schoolAS school_name VARCHAR2(100);BEGIN SELECT school INTO school_name FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB'; dbms_output.put_line(school_name);END; 执行存储过程，可以在PLSQL对象中看到我们刚才新创建的存储过程，并且没有报错，代表编译成功。 执行存储过程 1CALL stu_school(); 调用时，”()”是必不可少的，无论是有参数还是无参数 在SQL窗口输出页签中可以看到正确的输出内容 四种存储过程存储过程有一下四种情况 无参数存储过程 仅有输入参数存储过程 仅有输出参数存储过程 既有输入又有输出存储过程 下面将对这四种存储过程分别举例说明 无参数存储过程无参数存储过程就如上面写的那个简单的存储过程，也可以这样写： 123456CREATE OR REPLACE PROCEDURE stu_schoolAS school_name students.school%TYPE;BEGIN SELECT school INTO school_name FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB'; dbms_output.put_line(school_name);END; 仅有输入参数存储过程123456CREATE OR REPLACE PROCEDURE stu_address(stu_id IN students.id%TYPE)AS addr students.address%TYPE;BEGIN SELECT address INTO addr FROM students WHERE ID=stu_id; dbms_output.put_line(addr);END; 执行存储过程 1CALL stu_address('8A17DE17428E45D6E0530100007FABEB'); 仅有输出参数存储过程12345CREATE OR REPLACE PROCEDURE stu_age(stu_age OUT students.age%TYPE)ASBEGIN SELECT age INTO stu_age FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB';END; 需要注意的是，此种存储过程不能直接通过call来调用，需要通过一下方式执行 注意，如果通过这种方式执行存储过程，要记得在存储过程中添加输出语句，不然的话，纵然执行成功，也没有结果输出。dbms_output.put_line(stu_age); 12345DECLAREstuage students.age%TYPE;BEGIN stu_age(stuage);END; 或者通过oracle函数调用带有输出参数的存储过程 12345CREATE OR REPLACE FUNCTION get_stuage(stuage OUT NUMBER) RETURN NUMBER ISBEGIN stu_age(stuage); RETURN stuage;END; 执行函数 12345DECLARE stuage students.age%TYPE;BEGIN dbms_output.put_line('return result:' || get_stuage(stuage));END; 既有输入又有输出参数的存储过程12345CREATE OR REPLACE PROCEDURE stu_name(stuid IN students.id%TYPE, stuname OUT students.name%TYPE)ASBEGIN SELECT NAME INTO stuname FROM students WHERE ID=stuid;END; 新建存储函数调用存储过程 12345CREATE OR REPLACE FUNCTION get_stuname(stuid IN students.id%TYPE, stuname OUT students.name%TYPE) RETURN VARCHAR2 ISBEGIN stu_name(stuid, stuname); RETURN stuname;END; 执行函数 12345DECLARE stuname students.name%TYPE;BEGIN dbms_output.put_line('The student name is:' || get_stuname('8A17DE17428E45D6E0530100007FABEB', stuname));END; Java调用存储过程Java调用仅有输出参数的存储过程针对存储过程 stu_age 12345CREATE OR REPLACE PROCEDURE stu_age(stu_age OUT students.age%TYPE)ASBEGIN SELECT age INTO stu_age FROM students WHERE ID='8A17DE17428E45D6E0530100007FABEB';END; Java代码如下： 123456789101112131415private void OnlyOutputProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = "&#123;call stu_age(?)&#125;"; CallableStatement statement = connection.prepareCall(sql); statement.registerOutParameter(1, OracleTypes.NUMBER); statement.execute(); System.out.println(statement.getInt(1)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; Java调用既有输入参数又有输出参数的存储过程针对存储过程 stu_name 12345CREATE OR REPLACE PROCEDURE stu_name(stuid IN students.id%TYPE, stuname OUT students.name%TYPE)ASBEGIN SELECT NAME INTO stuname FROM students WHERE ID=stuid;END; Java代码如下： 12345678910111213141516private void InAndOutputProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = "&#123;call stu_name(?,?)&#125;"; CallableStatement statement = connection.prepareCall(sql); statement.setString(1, "8A17DE17428E45D6E0530100007FABEB"); statement.registerOutParameter(2, OracleTypes.VARCHAR); statement.execute(); System.out.println(statement.getString(2)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 以上是有OUT输出参数的存储过程，Java在调用存储过程后还会获得存储过程返回的参数。那么如果存储过程没有OUT输出参数怎么办？ Java调用仅有输入参数的存储过程1234567891011121314private void OnlyInputProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = "&#123;call stu_address(?)&#125;"; CallableStatement statement = connection.prepareCall(sql); statement.setString(1, "8A17DE17428E45D6E0530100007FABEB"); statement.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; Java调用无参的存储过程12345678910111213private void NoParameterProcedure() &#123; try &#123; Class.forName(DRVIER); Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = "&#123;call stu_school()&#125;"; CallableStatement statement = connection.prepareCall(sql); statement.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; Java调用存储函数以 get_stuname 存储过程为例 12345CREATE OR REPLACE PROCEDURE stu_name(stuid IN students.id%TYPE, stuname OUT students.name%TYPE)ASBEGIN SELECT NAME INTO stuname FROM students WHERE ID=stuid;END; 存储函数 get_stuname 调用 12345CREATE OR REPLACE FUNCTION get_stuname(stuid IN students.id%TYPE, stuname OUT students.name%TYPE) RETURN VARCHAR2 ISBEGIN stu_name(stuid, stuname); RETURN stuname;END; 这里有一个关于Oracle存储过程的PPT文档，供大家下载学习点击下载]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle 存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的ps命令解析]]></title>
    <url>%2F2018%2F03%2F01%2FLinux%E7%9A%84ps%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Linux的ps命令解析Linux ps命令用于显示当前进程 (process) 的状态。要对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程,ps命令就是最基本进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到。ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。 列出目前所有的正在内存当中的程序输入命令 1# ps aux USER：该进程属于那个使用者账号。 PID ：该进程的进程ID号。 %CPU：该进程使用掉的 CPU 资源百分比； %MEM：该进程所占用的物理内存百分比； VSZ ：该进程使用掉的虚拟内存量 (Kbytes) RSS ：该进程占用的固定的内存量 (Kbytes) TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示 ?。另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有： R ：该程序目前正在运作，或者是可被运作； S ：该程序目前正在睡眠当中，但可被某些讯号(signal) 唤醒。 T ：该程序目前正在侦测或者是停止了； Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态 START：该进程被触发启动的时间； TIME ：该进程实际使用 CPU 运作的时间。 COMMAND：该程序的实际指令。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git命令的使用心得]]></title>
    <url>%2F2017%2F03%2F11%2F%E5%85%B3%E4%BA%8EGit%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[文章摘自网易博客 Git 的origin和master分析，并且也增加了一些内容，大家互相学习。 ⚪ git的三大步骤首先要明确一点，对git的操作是围绕3个大的步骤来展开的（其实几乎所有的SCM都是这样） 1.从git取数据（git clone） 2.改动代码 3.将改动传回git（git push） 这3个步骤又涉及到两个repository，一个是remote repository，在远程服务器上，一个是local repository，在自己工作区上。其中1, 3两个步骤涉及到remote server/remote repository/remote branch，2涉及到local repository/local branch。git clone 会根据你指定的remote server/repository/branch，拷贝一个副本到你本地，再git push之前，你对所有文件的改动都是在你自己本地的local repository来做的，你的改动(local branch)和remote branch是独立（并行）的。 在clone完成之后，Git 会自动为你将此远程仓库命名为origin（origin只相当于一个别名，运行git remote –v或者查看.git/config可以看到origin的含义）(guyue: 即origin是代表远程仓库的一个默认别名, 可以在项目工程目录中.git/config文件中查看或修改)，并下载其中所有的数据，建立一个指向它的master 分支的指针，我们用(远程仓库名)/(分支名) 这样的形式表示远程分支，所以origin/master指向的是一个remote branch（从那个branch我们clone数据到本地），但你无法在本地更改其数据。 同时，Git 会建立一个属于你自己的本地master 分支，它指向的是你刚刚从remote server传到你本地的副本。随着你不断的改动文件，git add, git commit，master的指向会自动移动，你也可以通过merge（fast forward）来移动master的指向。 1234$ git branch -a (to show all the branches git knows about) * master remotes/origin/HEAD -&gt; origin/master remotes/origin/master 123$ git branch -r (to show remote branches git knows about) origin/HEAD -&gt; origin/master origin/master 可以发现，master就是local branch，origin/master是remote branch （master is a branch in the local repository. remotes/origin/master is a branch named master on the remote named origin） 1$ git diff origin/master master show me the changes between the remote master branch and my master branch 需要注意的是 remotes/origin/master和origin/master的指向是相同的 1$ git diff origin/master remotes/origin/master ⚪ 关于git push origin masterorigin指定了你要push到哪个remote。 master其实是一个“refspec”，正常的“refspec”的形式为”+:”，冒号前表示local branch的名字，冒号后表示remote repository下 branch的名字。注意，如果你省略了，git就认为你想push到remote repository下和local branch相同名字的branch。听起来有点拗口，再解释下，push是怎么个push法，就是把本地branch指向的commit push到remote repository下的branch，比如： 1$ git push origin master:master 在local repository中找到名字为master的branch，使用它去更新remote repository下名字为master的branch，如果remote repository下不存在名字是master的branch，那么新建一个。 1$ it push origin master 省略了，等价于“git push origin master:master”。 1$ git push origin master:refs/for/mybranch 在local repository中找到名字为master的branch，用他去更新remote repository下面名字为mybranch的branch。 1$ git push origin HEAD:refs/for/mybranch HEAD指向当前工作的branch，master不一定指向当前工作的branch，所以我觉得用HEAD还比master好些。 1$ git push origin :mybranch 再origin repository里面查找mybranch，删除它。用一个空的去更新它，就相当于删除了。 ⚪ Git比较本地仓库和远程仓库的差异假设本地分支为hexo，远程仓库origin的分支为master 首先更新本地的远程分支 1$ git fetch origin 然后我们可以查看一下远程仓库有而本地仓库没有的commit信息 1$ git log hexo..origin/master 最后查看具体文件差异（改动的地方） 1$ git diff --stat hexo origin/master 将远程存储库中的更改合并到当前分支中 1$ git pull origin master:hexo 如果当前分支已经是hexo，那么可以简写成 1$ git pull origin master 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git允许手动建立追踪关系 1$ git branch --set-upstream hexo origin/master 如果当前分支与远程分支存在追踪关系，git pull 可以简写成 1$ git pull origin ⚪ Git创建新分支并把新分支上传到Github远程仓库用Git创建一个分支，这个分支在远程仓库上是没有的，把这个新分支推送到远程仓库中。 创建分支并切换到该分支1$ git checkout -b hogwarts 推送新分支到远程仓库 1$ git push origin HEAD -u 在Github中查看]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2013%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>world</tag>
      </tags>
  </entry>
</search>
